import { EventEmitter, getDoc, ignoreDiagnostics, isTemplateDeclaration, mapEventEmitterToNodeListener, navigateProgram, SyntaxKind, } from "@typespec/compiler";
import { getResponsesForOperation } from "@typespec/http";
import { reportDiagnostic } from "./lib.js";
import { createArrayIdentifiersRule } from "./rules/array-identifiers.js";
import { createVersioningRule } from "./rules/index.js";
export async function $onValidate(p) {
    runLinter(p);
}
function isInlineModel(target) {
    return !target.name;
}
/**
 *
 *@param target
 *@returns true if the operation is defined on a templated interface which hasn't had args filled in
 */
function isTemplatedInterfaceOperation(target) {
    var _a;
    return (((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.OperationStatement &&
        target.interface &&
        isTemplateDeclaration(target.interface));
}
/**
 *
 *@param target
 *@returns true if the operation is an uninstantiated signature template
 */
function isTemplatedOperationSignature(target) {
    var _a;
    return ((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.OperationStatement && isTemplateDeclaration(target);
}
function createListenerOnGeneralType(fn) {
    const listener = {
        namespace: fn,
        interface: fn,
        operation: fn,
        model: fn,
        scalar: fn,
        modelProperty: fn,
        templateParameter: fn,
        enum: fn,
        union: fn,
        unionVariant: fn,
        tuple: fn,
    };
    return listener;
}
function getResponseStatusCodes(program, operation) {
    return ignoreDiagnostics(getResponsesForOperation(program, operation)).map((res) => res.statusCodes);
}
class Linter {
    constructor() {
        this.eventEmitter = new EventEmitter();
    }
    run(p) {
        navigateProgram(p, mapEventEmitterToNodeListener(this.eventEmitter));
    }
    register(listeners) {
        const listenerList = Array.isArray(listeners) ? listeners : [listeners];
        for (const listeners of listenerList) {
            for (const [name, listener] of Object.entries(listeners)) {
                this.eventEmitter.on(name, listener);
            }
        }
    }
}
const runLinter = (p) => {
    function isDocumentationSameAsNodeName(target) {
        const docText = getDoc(p, target);
        const nodeName = target.name;
        if (typeof docText === "string" &&
            typeof nodeName === "string" &&
            docText.trim().toLowerCase() === nodeName.toLowerCase()) {
            reportDiagnostic(p, { code: "documentation-different-with-node-name", target });
        }
    }
    const checkDocumentationText = createListenerOnGeneralType(isDocumentationSameAsNodeName);
    const checkInlineModel = {
        model: (context) => {
            // the empty model'{}' can be ignored.
            if (isInlineModel(context) && context.properties.size > 0) {
                reportDiagnostic(p, { code: "no-inline-model", target: context });
            }
        },
    };
    const checkOperationResponses = {
        operation: (context) => {
            if (isTemplatedInterfaceOperation(context) || isTemplatedOperationSignature(context)) {
                return;
            }
            const responseCodes = getResponseStatusCodes(p, context);
            const successfulCodes = [200, 201, 202, 204];
            if (!responseCodes.some((code) => typeof code === "number" && successfulCodes.includes(code))) {
                reportDiagnostic(p, {
                    code: "no-success-response-code",
                    target: context,
                });
            }
        },
    };
    const linter = new Linter();
    linter.register([
        checkInlineModel,
        checkDocumentationText,
        createArrayIdentifiersRule(p),
        checkOperationResponses,
        createVersioningRule(p),
    ]);
    return linter.run(p);
};
//# sourceMappingURL=linter.js.map