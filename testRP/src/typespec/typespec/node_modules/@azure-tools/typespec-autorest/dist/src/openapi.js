import { extractLroStates, getAsEmbeddingVector, getLroMetadata, getPagedResult, getUnionAsEnum, isFixed, } from "@azure-tools/typespec-azure-core";
import { NoTarget, SyntaxKind, TwoLevelMap, compilerAssert, createProjectedNameProgram, emitFile, getAllTags, getDirectoryPath, getDiscriminator, getDoc, getEncode, getFormat, getKnownValues, getMaxItems, getMaxLength, getMaxValue, getMinItems, getMinLength, getMinValue, getNamespaceFullName, getPattern, getProperty, getPropertyType, getRelativePathFromDirectory, getRootLength, getService, getSummary, getVisibility, ignoreDiagnostics, interpolatePath, isArrayModelType, isDeprecated, isErrorModel, isErrorType, isGlobalNamespace, isNeverType, isNullType, isNumericType, isRecordModelType, isSecret, isService, isStringType, isTemplateDeclaration, isTemplateDeclarationOrInstance, isVoidType, listServices, navigateTypesInNamespace, projectProgram, resolveEncodedName, resolvePath, stringTemplateToString, } from "@typespec/compiler";
import { Visibility, createMetadataInfo, getAllHttpServices, getAuthentication, getHeaderFieldOptions, getQueryParamOptions, getServers, getStatusCodeDescription, getVisibilitySuffix, isContentTypeHeader, isSharedRoute, reportIfNoRoutes, resolveRequestVisibility, } from "@typespec/http";
import { checkDuplicateTypeName, getExtensions, getExternalDocs, getInfo, getOpenAPITypeName, getParameterKey, isReadonlyProperty, shouldInline, } from "@typespec/openapi";
import { buildVersionProjections } from "@typespec/versioning";
import { AutorestOpenAPISchema } from "./autorest-openapi-schema.js";
import { getExamples, getRef } from "./decorators.js";
import { sortWithJsonSchema } from "./json-schema-sorter/sorter.js";
import { getTracer, reportDiagnostic } from "./lib.js";
import { resolveOperationId } from "./utils.js";
const defaultOptions = {
    "output-file": "{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json",
    "new-line": "lf",
    "include-x-typespec-name": "never",
};
export async function $onEmit(context) {
    var _a;
    const resolvedOptions = { ...defaultOptions, ...context.options };
    const armTypesDir = interpolatePath((_a = resolvedOptions["arm-types-dir"]) !== null && _a !== void 0 ? _a : "{project-root}/../../common-types/resource-management", {
        "project-root": context.program.projectRoot,
        "emitter-output-dir": context.emitterOutputDir,
    });
    const options = {
        outputFile: resolvedOptions["output-file"],
        outputDir: context.emitterOutputDir,
        azureResourceProviderFolder: resolvedOptions["azure-resource-provider-folder"],
        examplesDirectory: resolvedOptions["examples-directory"],
        version: resolvedOptions["version"],
        newLine: resolvedOptions["new-line"],
        omitUnreachableTypes: resolvedOptions["omit-unreachable-types"],
        includeXTypeSpecName: resolvedOptions["include-x-typespec-name"],
        armTypesDir,
        useReadOnlyStatusSchema: resolvedOptions["use-read-only-status-schema"],
    };
    const emitter = createOAPIEmitter(context.program, options);
    await emitter.emitOpenAPI();
}
function getEmitterDetails(program) {
    return [{ emitter: "@azure-tools/typespec-autorest" }];
}
/**
 * Represents a node that will hold a JSON reference. The value is computed
 * at the end so that we can defer decisions about the name that is
 * referenced.
 */
class Ref {
    toJSON() {
        compilerAssert(this.value, "Reference value never set.");
        return this.value;
    }
}
function createOAPIEmitter(program, options) {
    const tracer = getTracer(program);
    tracer.trace("options", JSON.stringify(options, null, 2));
    const typeNameOptions = {
        // shorten type names by removing TypeSpec and service namespace
        namespaceFilter(ns) {
            return !isService(program, ns);
        },
    };
    let root;
    let currentEndpoint;
    let currentConsumes;
    let currentProduces;
    let metadataInfo;
    // Keep a map of all Types+Visibility combinations that were encountered
    // that need schema definitions.
    let pendingSchemas = new TwoLevelMap();
    // Reuse a single ref object per Type+Visibility combination.
    let refs = new TwoLevelMap();
    // Keep track of inline types still in the process of having their schema computed
    // This is used to detect cycles in inline types, which is an
    let inProgressInlineTypes = new Set();
    // Map model properties that represent shared parameters to their parameter
    // definition that will go in #/parameters. Inlined parameters do not go in
    // this map.
    let params;
    // Keep track of models that have had properties spread into parameters. We won't
    // consider these unreferenced when emitting unreferenced types.
    let paramModels;
    // De-dupe the per-endpoint tags that will be added into the #/tags
    let tags;
    // The set of produces/consumes values found in all operations
    const globalProduces = new Set(["application/json"]);
    const globalConsumes = new Set(["application/json"]);
    let operationExamplesMap;
    let operationIdsWithExample;
    let outputFile;
    let jsonView;
    let clientView;
    let context;
    async function emitOpenAPI() {
        const services = listServices(program);
        if (services.length === 0) {
            services.push({ type: program.getGlobalNamespaceType() });
        }
        for (const service of services) {
            const originalProgram = program;
            const versions = buildVersionProjections(program, service.type).filter((v) => !options.version || options.version === v.version);
            for (const record of versions) {
                let projectedProgram;
                if (record.projections.length > 0) {
                    projectedProgram = program = projectProgram(originalProgram, record.projections);
                }
                jsonView = createProjectedNameProgram(program, "json");
                clientView = createProjectedNameProgram(program, "client");
                context = {
                    program,
                    service,
                    version: record.version,
                    jsonView,
                    clientView,
                };
                const projectedServiceNs = projectedProgram
                    ? projectedProgram.projector.projectedTypes.get(service.type)
                    : service.type;
                await emitOpenAPIFromVersion(projectedServiceNs === program.getGlobalNamespaceType()
                    ? { type: program.getGlobalNamespaceType() }
                    : getService(program, projectedServiceNs), services.length > 1, record.version);
            }
        }
    }
    return { emitOpenAPI };
    function initializeEmitter(service, multipleService, version) {
        var _a, _b, _c;
        const auth = processAuth(service.type);
        root = {
            swagger: "2.0",
            info: {
                title: (_a = service.title) !== null && _a !== void 0 ? _a : "(title)",
                version: (_b = version !== null && version !== void 0 ? version : service.version) !== null && _b !== void 0 ? _b : "0000-00-00",
                description: getDoc(program, service.type),
                ...getInfo(program, service.type),
                "x-typespec-generated": getEmitterDetails(program),
            },
            schemes: ["https"],
            ...resolveHost(program, service.type),
            externalDocs: getExternalDocs(program, service.type),
            produces: [], // Pre-initialize produces and consumes so that
            consumes: [], // they show up at the top of the document
            security: auth === null || auth === void 0 ? void 0 : auth.security,
            securityDefinitions: (_c = auth === null || auth === void 0 ? void 0 : auth.securitySchemes) !== null && _c !== void 0 ? _c : {},
            tags: [],
            paths: {},
            "x-ms-paths": {},
            definitions: {},
            parameters: {},
        };
        pendingSchemas = new TwoLevelMap();
        refs = new TwoLevelMap();
        metadataInfo = createMetadataInfo(program, {
            canonicalVisibility: Visibility.Read,
            canShareProperty: canSharePropertyUsingReadonlyOrXMSMutability,
        });
        inProgressInlineTypes = new Set();
        params = new Map();
        paramModels = new Set();
        tags = new Set();
        operationExamplesMap = new Map();
        operationIdsWithExample = new Set();
        outputFile = resolveOutputFile(service, multipleService, options, version);
    }
    function resolveHost(program, namespace) {
        var _a;
        const servers = getServers(program, namespace);
        if (servers === undefined) {
            return {};
        }
        // If there is more than one server we then just make a custom host with a parameter asking for the full url.
        if (servers.length > 1) {
            return {
                "x-ms-parameterized-host": {
                    hostTemplate: "{url}",
                    useSchemePrefix: false,
                    parameters: [
                        {
                            name: "url",
                            in: "path",
                            description: "Url",
                            type: "string",
                            format: "uri",
                            "x-ms-skip-url-encoding": true,
                        },
                    ],
                },
            };
        }
        const server = servers[0];
        if (server.parameters.size === 0) {
            const [scheme, host] = server.url.split("://");
            return {
                host,
                schemes: [scheme],
            };
        }
        const parameters = [];
        for (const prop of server.parameters.values()) {
            const param = getOpenAPI2Parameter(prop, "path", Visibility.Read);
            if (prop.type.kind === "Scalar" &&
                ignoreDiagnostics(program.checker.isTypeAssignableTo((_a = prop.type.projectionBase) !== null && _a !== void 0 ? _a : prop.type, program.checker.getStdType("url"), prop.type))) {
                param["x-ms-skip-url-encoding"] = true;
            }
            parameters.push(param);
        }
        return {
            "x-ms-parameterized-host": {
                hostTemplate: server.url,
                useSchemePrefix: false,
                parameters,
            },
        };
    }
    async function emitOpenAPIFromVersion(service, multipleService, version) {
        initializeEmitter(service, multipleService, version);
        try {
            await loadExamples(version);
            const services = ignoreDiagnostics(getAllHttpServices(program));
            const routes = services[0].operations;
            reportIfNoRoutes(program, routes);
            routes.forEach(emitOperation);
            emitParameters();
            emitSchemas(service.type);
            emitTags();
            // Finalize global produces/consumes
            if (globalProduces.size > 0) {
                root.produces = [...globalProduces.values()];
            }
            else {
                delete root.produces;
            }
            if (globalConsumes.size > 0) {
                root.consumes = [...globalConsumes.values()];
            }
            else {
                delete root.consumes;
            }
            // Clean up empty entries
            if (root["x-ms-paths"] && Object.keys(root["x-ms-paths"]).length === 0) {
                delete root["x-ms-paths"];
            }
            if (root.security && Object.keys(root.security).length === 0) {
                delete root["security"];
            }
            if (root.securityDefinitions && Object.keys(root.securityDefinitions).length === 0) {
                delete root["securityDefinitions"];
            }
            if (!program.compilerOptions.noEmit && !program.hasError()) {
                // Sort the document
                const sortedRoot = sortOpenAPIDocument(root);
                // Write out the OpenAPI document to the output path
                await emitFile(program, {
                    path: outputFile,
                    content: prettierOutput(JSON.stringify(sortedRoot, null, 2)),
                    newLine: options.newLine,
                });
                // Copy examples to the output directory
                if (options.examplesDirectory && operationIdsWithExample.size > 0) {
                    const examplesPath = resolvePath(getDirectoryPath(outputFile), "examples");
                    const exampleDir = version
                        ? resolvePath(options.examplesDirectory, version)
                        : resolvePath(options.examplesDirectory);
                    await program.host.mkdirp(examplesPath);
                    for (const operationId of operationIdsWithExample) {
                        const examples = operationExamplesMap.get(operationId);
                        if (examples) {
                            for (const [_, fileName] of Object.entries(examples)) {
                                const content = await program.host.readFile(resolvePath(exampleDir, fileName));
                                await emitFile(program, {
                                    path: resolvePath(examplesPath, fileName),
                                    content: content.text,
                                    newLine: options.newLine,
                                });
                            }
                        }
                    }
                }
            }
        }
        catch (err) {
            if (err instanceof ErrorTypeFoundError) {
                // Return early, there must be a parse error if an ErrorType was
                // inserted into the TypeSpec output
                return;
            }
            else {
                throw err;
            }
        }
    }
    function parseNextLinkName(paged) {
        const pathComponents = paged.nextLinkSegments;
        if (pathComponents) {
            return pathComponents[pathComponents.length - 1];
        }
        return undefined;
    }
    function extractPagedMetadataNested(program, type) {
        // This only works for `is Page<T>` not `extends Page<T>`.
        let paged = getPagedResult(program, type);
        if (paged) {
            return paged;
        }
        if (type.baseModel) {
            paged = getPagedResult(program, type.baseModel);
        }
        if (paged) {
            return paged;
        }
        const templateArguments = type.templateMapper;
        if (templateArguments) {
            for (const argument of templateArguments.args) {
                const modelArgument = argument;
                if (modelArgument) {
                    paged = extractPagedMetadataNested(program, modelArgument);
                    if (paged) {
                        return paged;
                    }
                }
            }
        }
        return paged;
    }
    function extractPagedMetadata(program, operation) {
        for (const response of operation.responses) {
            const paged = extractPagedMetadataNested(program, response.type);
            if (paged) {
                const nextLinkName = parseNextLinkName(paged);
                if (nextLinkName) {
                    currentEndpoint["x-ms-pageable"] = {
                        nextLinkName,
                    };
                }
                // Once we find paged metadata, we don't need to processes any further.
                return;
            }
        }
    }
    function requiresXMsPaths(path, operation) {
        var _a;
        const isShared = (_a = isSharedRoute(program, operation)) !== null && _a !== void 0 ? _a : false;
        if (path.includes("?")) {
            return true;
        }
        return isShared;
    }
    function getPathWithoutQuery(path) {
        // strip everything from the key including and after the ?
        return path.replace(/\/?\?.*/, "");
    }
    function emitOperation(operation) {
        var _a, _b;
        let { path: fullPath, operation: op, verb, parameters } = operation;
        let pathsObject = root.paths;
        const pathWithoutAnyQuery = getPathWithoutQuery(fullPath);
        if (((_a = root.paths[pathWithoutAnyQuery]) === null || _a === void 0 ? void 0 : _a[verb]) === undefined) {
            fullPath = pathWithoutAnyQuery;
            pathsObject = root.paths;
        }
        else if (requiresXMsPaths(fullPath, op)) {
            // if the key already exists in x-ms-paths, append
            // the operation id.
            if (fullPath.includes("?")) {
                if (((_b = root["x-ms-paths"]) === null || _b === void 0 ? void 0 : _b[fullPath]) !== undefined) {
                    fullPath += `&_overload=${operation.operation.name}`;
                }
            }
            else {
                fullPath += `?_overload=${operation.operation.name}`;
            }
            pathsObject = root["x-ms-paths"];
        }
        else {
            // This should not happen because http library should have already validated duplicate path or the routes must have been using shared routes and so goes in previous condition.
            compilerAssert(false, `Duplicate route "${fullPath}". This is unexpected.`);
        }
        if (!pathsObject[fullPath]) {
            pathsObject[fullPath] = {};
        }
        const currentPath = pathsObject[fullPath];
        if (!currentPath[verb]) {
            currentPath[verb] = {};
        }
        currentEndpoint = currentPath[verb];
        currentConsumes = new Set();
        currentProduces = new Set();
        const currentTags = getAllTags(program, op);
        if (currentTags) {
            currentEndpoint.tags = currentTags;
            for (const tag of currentTags) {
                // Add to root tags if not already there
                tags.add(tag);
            }
        }
        currentEndpoint.operationId = resolveOperationId(context, op);
        applyExternalDocs(op, currentEndpoint);
        // Set up basic endpoint fields
        currentEndpoint.summary = getSummary(program, op);
        currentEndpoint.description = getDoc(program, op);
        currentEndpoint.parameters = [];
        currentEndpoint.responses = {};
        const lroMetadata = getLroMetadata(program, op);
        // We ignore GET operations because they cannot be LROs per our guidelines and this
        // ensures we don't add the x-ms-long-running-operation extension to the polling operation,
        // which does have LRO metadata.
        if (lroMetadata !== undefined && operation.verb !== "get") {
            currentEndpoint["x-ms-long-running-operation"] = true;
        }
        // Extract paged metadata from Azure.Core.Page
        extractPagedMetadata(program, operation);
        const visibility = resolveRequestVisibility(program, operation.operation, verb);
        emitEndpointParameters(parameters, visibility);
        emitResponses(operation.responses);
        applyEndpointConsumes();
        applyEndpointProduces();
        if (isDeprecated(program, op)) {
            currentEndpoint.deprecated = true;
        }
        const examples = getExamples(program, op);
        if (examples) {
            currentEndpoint["x-ms-examples"] = examples.reduce((acc, example) => ({ ...acc, [example.title]: { $ref: example.pathOrUri } }), {});
        }
        if (options.examplesDirectory) {
            const examples = operationExamplesMap.get(currentEndpoint.operationId);
            if (examples && currentEndpoint.operationId) {
                operationIdsWithExample.add(currentEndpoint.operationId);
                currentEndpoint["x-ms-examples"] = currentEndpoint["x-ms-examples"] || {};
                for (const [title, fileName] of Object.entries(examples)) {
                    currentEndpoint["x-ms-examples"][title] = { $ref: `./examples/${fileName}` };
                }
            }
        }
        // Attach additional extensions after main fields
        attachExtensions(op, currentEndpoint);
    }
    function applyEndpointProduces() {
        if (currentProduces.size > 0 && !checkLocalAndGlobalEqual(globalProduces, currentProduces)) {
            currentEndpoint.produces = [...currentProduces];
        }
    }
    function applyEndpointConsumes() {
        if (currentConsumes.size > 0 && !checkLocalAndGlobalEqual(globalConsumes, currentConsumes)) {
            currentEndpoint.consumes = [...currentConsumes];
        }
    }
    function checkLocalAndGlobalEqual(global, local) {
        if (global.size !== local.size) {
            return false;
        }
        for (const entry of local) {
            if (!global.has(entry)) {
                return false;
            }
        }
        return true;
    }
    function isBytes(type) {
        var _a;
        const baseType = (_a = type.projectionBase) !== null && _a !== void 0 ? _a : type;
        return ignoreDiagnostics(program.checker.isTypeAssignableTo(baseType, program.checker.getStdType("bytes"), type));
    }
    function isBinaryPayload(body, contentType) {
        const types = new Set(typeof contentType === "string" ? [contentType] : contentType);
        return (body.kind === "Scalar" &&
            body.name === "bytes" &&
            !types.has("application/json") &&
            !types.has("text/plain"));
    }
    function emitResponses(responses) {
        for (const response of responses) {
            for (const statusCode of getOpenAPI2StatusCodes(response.statusCodes, response.type)) {
                emitResponseObject(statusCode, response);
            }
        }
    }
    function getOpenAPI2StatusCodes(statusCodes, diagnosticTarget) {
        if (statusCodes === "*") {
            return ["default"];
        }
        else if (typeof statusCodes === "number") {
            return [String(statusCodes)];
        }
        else {
            return rangeToOpenAPI(statusCodes, diagnosticTarget);
        }
    }
    function rangeToOpenAPI(range, diagnosticTarget) {
        const reportInvalid = () => reportDiagnostic(program, {
            code: "unsupported-status-code-range",
            format: { start: String(range.start), end: String(range.end) },
            target: diagnosticTarget,
        });
        const codes = [];
        let start = range.start;
        let end = range.end;
        if (range.start < 100) {
            reportInvalid();
            start = 100;
            codes.push("default");
        }
        else if (range.end > 599) {
            reportInvalid();
            codes.push("default");
            end = 599;
        }
        const groups = [1, 2, 3, 4, 5];
        for (const group of groups) {
            if (start > end) {
                break;
            }
            const groupStart = group * 100;
            const groupEnd = groupStart + 99;
            if (start >= groupStart && start <= groupEnd) {
                codes.push(`${group}XX`);
                if (start !== groupStart || end < groupEnd) {
                    reportInvalid();
                }
                start = groupStart + 100;
            }
        }
        return codes;
    }
    function getResponseDescriptionForStatusCode(statusCode) {
        var _a;
        if (statusCode === "default") {
            return "An unexpected error response.";
        }
        return (_a = getStatusCodeDescription(statusCode)) !== null && _a !== void 0 ? _a : "unknown";
    }
    function emitResponseObject(statusCode, response) {
        var _a, _b, _c;
        const openapiResponse = (_a = currentEndpoint.responses[statusCode]) !== null && _a !== void 0 ? _a : {
            description: (_b = response.description) !== null && _b !== void 0 ? _b : getResponseDescriptionForStatusCode(statusCode),
        };
        if (isErrorModel(program, response.type) && statusCode !== "default") {
            openapiResponse["x-ms-error-response"] = true;
        }
        const contentTypes = [];
        let body;
        for (const data of response.responses) {
            if (data.headers && Object.keys(data.headers).length > 0) {
                (_c = openapiResponse.headers) !== null && _c !== void 0 ? _c : (openapiResponse.headers = {});
                for (const [key, value] of Object.entries(data.headers)) {
                    openapiResponse.headers[key] = getResponseHeader(value);
                }
            }
            if (data.body) {
                if (body && body !== data.body.type) {
                    reportDiagnostic(program, {
                        code: "duplicate-body-types",
                        target: response.type,
                    });
                }
                body = data.body.type;
                contentTypes.push(...data.body.contentTypes);
            }
        }
        if (body) {
            const isBinary = contentTypes.every((t) => isBinaryPayload(body, t));
            openapiResponse.schema = isBinary ? { type: "file" } : getSchemaOrRef(body, Visibility.Read);
        }
        for (const contentType of contentTypes) {
            currentProduces.add(contentType);
        }
        currentEndpoint.responses[statusCode] = openapiResponse;
    }
    function getResponseHeader(prop) {
        const header = {};
        populateParameter(header, prop, "header", Visibility.Read);
        delete header.in;
        delete header.name;
        delete header.required;
        return header;
    }
    function resolveRef(ref) {
        const absoluteRef = interpolatePath(ref, {
            "arm-types-dir": options.armTypesDir,
        });
        if (getRootLength(absoluteRef) === 0) {
            return absoluteRef; // It is already relative.
        }
        return getRelativePathFromDirectory(getDirectoryPath(outputFile), absoluteRef, false);
    }
    function getSchemaOrRef(type, visibility) {
        var _a;
        const refUrl = getRef(program, type, { version: context.version, service: context.service });
        if (refUrl) {
            return {
                $ref: resolveRef(refUrl),
            };
        }
        if (type.kind === "Scalar" && program.checker.isStdType(type)) {
            return getSchemaForScalar(type);
        }
        if (type.kind === "String" || type.kind === "Number" || type.kind === "Boolean") {
            // For literal types, we just want to emit them directly as well.
            return getSchemaForLiterals(type);
        }
        if (type.kind === "StringTemplate") {
            return getSchemaForStringTemplate(type);
        }
        if (type.kind === "Intrinsic" && type.name === "unknown") {
            return getSchemaForIntrinsicType(type);
        }
        if (type.kind === "EnumMember") {
            // Enum members are just the OA representation of their values.
            if (typeof type.value === "number") {
                return { type: "number", enum: [type.value] };
            }
            else {
                return { type: "string", enum: [(_a = type.value) !== null && _a !== void 0 ? _a : type.name] };
            }
        }
        if (type.kind === "ModelProperty") {
            return resolveProperty(type, visibility);
        }
        type = metadataInfo.getEffectivePayloadType(type, visibility);
        const name = getOpenAPITypeName(program, type, typeNameOptions);
        if (shouldInline(program, type)) {
            const schema = getSchemaForInlineType(type, name, visibility);
            if (schema === undefined && isErrorType(type)) {
                // Exit early so that syntax errors are exposed.  This error will
                // be caught and handled in emitOpenAPI.
                throw new ErrorTypeFoundError();
            }
            // helps to read output and correlate to TypeSpec
            if (schema && options.includeXTypeSpecName !== "never") {
                schema["x-typespec-name"] = name;
            }
            return schema;
        }
        else {
            // Use shared schema when type is not transformed by visibility from the canonical read visibility.
            if (!metadataInfo.isTransformed(type, visibility)) {
                visibility = Visibility.Read;
            }
            const pending = pendingSchemas.getOrAdd(type, visibility, () => ({
                type,
                visibility,
                ref: refs.getOrAdd(type, visibility, () => new Ref()),
            }));
            return { $ref: pending.ref };
        }
    }
    function getSchemaForInlineType(type, name, visibility) {
        if (inProgressInlineTypes.has(type)) {
            reportDiagnostic(program, {
                code: "inline-cycle",
                format: { type: name },
                target: type,
            });
            return {};
        }
        inProgressInlineTypes.add(type);
        const schema = getSchemaForType(type, visibility);
        inProgressInlineTypes.delete(type);
        return schema;
    }
    function getParamPlaceholder(property) {
        let spreadParam = false;
        if (property.sourceProperty) {
            // chase our sources all the way back to the first place this property
            // was defined.
            spreadParam = true;
            property = property.sourceProperty;
            while (property.sourceProperty) {
                property = property.sourceProperty;
            }
        }
        const refUrl = getRef(program, property, {
            version: context.version,
            service: context.service,
        });
        if (refUrl) {
            return {
                $ref: resolveRef(refUrl),
            };
        }
        const parameter = params.get(property);
        if (parameter) {
            return parameter;
        }
        const placeholder = {};
        // only parameters inherited by spreading from non-inlined type are shared in #/parameters
        if (spreadParam && property.model && !shouldInline(program, property.model)) {
            params.set(property, placeholder);
            paramModels.add(property.model);
        }
        return placeholder;
    }
    function getJsonName(type) {
        const viaProjection = jsonView.getProjectedName(type);
        const encodedName = resolveEncodedName(program, type, "application/json");
        // Pick the value set via `encodedName` or default back to the legacy projection otherwise.
        // `resolveEncodedName` will return the original name if no @encodedName so we have to do that check
        return encodedName === type.name ? viaProjection : encodedName;
    }
    function emitEndpointParameters(methodParams, visibility) {
        var _a, _b;
        const consumes = (_b = (_a = methodParams.body) === null || _a === void 0 ? void 0 : _a.contentTypes) !== null && _b !== void 0 ? _b : [];
        for (const httpOpParam of methodParams.parameters) {
            const shared = params.get(httpOpParam.param);
            if (shared) {
                currentEndpoint.parameters.push(shared);
                continue;
            }
            if (httpOpParam.type === "header" && isContentTypeHeader(program, httpOpParam.param)) {
                continue;
            }
            emitParameter(httpOpParam.param, httpOpParam.type, visibility, httpOpParam.name);
        }
        if (consumes.length === 0 && methodParams.body) {
            // we didn't find an explicit content type anywhere, so infer from body.
            if (getModelOrScalarTypeIfNullable(methodParams.body.type)) {
                consumes.push("application/json");
            }
        }
        for (const consume of consumes) {
            currentConsumes.add(consume);
        }
        if (methodParams.body && !isVoidType(methodParams.body.type)) {
            const isBinary = isBinaryPayload(methodParams.body.type, consumes);
            const schema = isBinary
                ? { type: "string", format: "binary" }
                : getSchemaOrRef(methodParams.body.type, visibility);
            if (currentConsumes.has("multipart/form-data")) {
                const bodyModelType = methodParams.body.type;
                // Assert, this should never happen. Rest library guard against that.
                compilerAssert(bodyModelType.kind === "Model", "Body should always be a Model.");
                if (bodyModelType) {
                    for (const param of bodyModelType.properties.values()) {
                        emitParameter(param, "formData", visibility, getJsonName(param));
                    }
                }
            }
            else if (methodParams.body.parameter) {
                emitParameter(methodParams.body.parameter, "body", visibility, getJsonName(methodParams.body.parameter), schema);
            }
            else {
                currentEndpoint.parameters.push({
                    name: "body",
                    in: "body",
                    schema,
                    required: true,
                });
            }
        }
    }
    function getModelOrScalarTypeIfNullable(type) {
        if (type.kind === "Model" || type.kind === "Scalar") {
            return type;
        }
        else if (type.kind === "Union") {
            // Remove all `null` types and make sure there's a single model type
            const nonNulls = [...type.variants.values()]
                .map((x) => x.type)
                .filter((variant) => !isNullType(variant));
            if (nonNulls.every((t) => t.kind === "Model" || t.kind === "Scalar")) {
                return nonNulls.length === 1 ? nonNulls[0] : undefined;
            }
        }
        return undefined;
    }
    function emitParameter(param, kind, visibility, name, typeOverride) {
        if (isNeverType(param.type)) {
            return;
        }
        const ph = getParamPlaceholder(param);
        currentEndpoint.parameters.push(ph);
        // If the parameter already has a $ref, don't bother populating it
        if (!("$ref" in ph)) {
            populateParameter(ph, param, kind, visibility, name, typeOverride);
        }
    }
    function getSchemaForPrimitiveItems(type, visibility, paramName, multipart) {
        const fullSchema = getSchemaForType(type, visibility);
        if (fullSchema === undefined) {
            return undefined;
        }
        if (fullSchema.type === "object") {
            reportDiagnostic(program, {
                code: multipart ? "unsupported-multipart-type" : "unsupported-param-type",
                format: { part: paramName },
                target: type,
            });
            return { type: "string" };
        }
        return fullSchema;
    }
    function getFormDataSchema(type, visibility, paramName) {
        if (isBytes(type)) {
            return { type: "file" };
        }
        if (type.kind === "Model" && isArrayModelType(program, type)) {
            const elementType = type.indexer.value;
            if (isBytes(elementType)) {
                return { type: "array", items: { type: "string", format: "binary" } };
            }
            const schema = getSchemaForPrimitiveItems(elementType, visibility, paramName, true);
            if (schema === undefined) {
                return undefined;
            }
            delete schema.description;
            return {
                type: "array",
                items: schema,
            };
        }
        else {
            const schema = getSchemaForPrimitiveItems(type, visibility, paramName, true);
            if (schema === undefined) {
                return undefined;
            }
            return schema;
        }
    }
    function getOpenAPI2Parameter(param, kind, visibility, name, bodySchema) {
        var _a;
        const ph = {
            name: name !== null && name !== void 0 ? name : param.name,
            in: kind,
            required: !param.optional,
            description: getDoc(program, param),
        };
        if (param.name !== ph.name) {
            ph["x-ms-client-name"] = param.name;
        }
        if (param.default) {
            ph.default = getDefaultValue(param.default);
        }
        if (ph.in === "body") {
            compilerAssert(bodySchema, "bodySchema argument is required to populate body parameter");
            ph.schema = bodySchema;
        }
        else if (ph.in === "formData") {
            Object.assign(ph, getFormDataSchema(param.type, visibility, ph.name));
        }
        else {
            const collectionFormat = (_a = (kind === "query"
                ? getQueryParamOptions(program, param)
                : kind === "header"
                    ? getHeaderFieldOptions(program, param)
                    : undefined)) === null || _a === void 0 ? void 0 : _a.format;
            if (collectionFormat === "multi" && !["query", "header", "formData"].includes(ph.in)) {
                reportDiagnostic(program, { code: "invalid-multi-collection-format", target: param });
            }
            if (collectionFormat) {
                ph.collectionFormat = collectionFormat;
            }
            if (param.type.kind === "Model" && isArrayModelType(program, param.type)) {
                ph.type = "array";
                const schema = {
                    ...getSchemaForPrimitiveItems(param.type.indexer.value, visibility, ph.name),
                };
                delete schema.description;
                ph.items = schema;
            }
            else {
                Object.assign(ph, getSchemaForPrimitiveItems(param.type, visibility, ph.name));
            }
        }
        attachExtensions(param, ph);
        // Apply decorators to a copy of the parameter definition.  We use
        // Object.assign here because applyIntrinsicDecorators returns a new object
        // based on the target object and we need to apply its changes back to the
        // original parameter.
        Object.assign(ph, applyIntrinsicDecorators(param, { type: ph.type, format: ph.format }));
        return ph;
    }
    function populateParameter(ph, param, kind, visibility, name, bodySchema) {
        Object.assign(ph, getOpenAPI2Parameter(param, kind, visibility, name, bodySchema));
    }
    function emitParameters() {
        for (const [property, param] of params) {
            // Add an extension which tells AutoRest that this is a shared operation
            // parameter definition
            if (param["x-ms-parameter-location"] === undefined) {
                param["x-ms-parameter-location"] = "method";
            }
            const key = getParameterKey(program, property, param, root.parameters, typeNameOptions);
            root.parameters[key] = { ...param };
            const refedParam = param;
            for (const key of Object.keys(param)) {
                delete refedParam[key];
            }
            refedParam["$ref"] = "#/parameters/" + encodeURIComponent(key);
        }
    }
    function emitSchemas(serviceNamespace) {
        const processedSchemas = new TwoLevelMap();
        processSchemas();
        if (!options.omitUnreachableTypes) {
            processUnreferencedSchemas();
        }
        // Emit the processed schemas. Only now can we compute the names as it
        // depends on whether we have produced multiple schemas for a single
        // TYPESPEC type.
        for (const group of processedSchemas.values()) {
            for (const [visibility, processed] of group) {
                let name = getOpenAPITypeName(program, processed.type, typeNameOptions);
                if (group.size > 1) {
                    name += getVisibilitySuffix(visibility, Visibility.Read);
                }
                checkDuplicateTypeName(program, processed.type, name, root.definitions);
                processed.ref.value = "#/definitions/" + encodeURIComponent(name);
                if (processed.schema) {
                    root.definitions[name] = processed.schema;
                }
            }
        }
        function processSchemas() {
            // Process pending schemas. Note that getSchemaForType may pull in new
            // pending schemas so we iterate until there are no pending schemas
            // remaining.
            while (pendingSchemas.size > 0) {
                for (const [type, group] of pendingSchemas) {
                    for (const [visibility, pending] of group) {
                        processedSchemas.getOrAdd(type, visibility, () => ({
                            ...pending,
                            schema: getSchemaForType(type, visibility),
                        }));
                    }
                    pendingSchemas.delete(type);
                }
            }
        }
        function processUnreferencedSchemas() {
            const addSchema = (type) => {
                if (!processedSchemas.has(type) && !paramModels.has(type) && !shouldInline(program, type)) {
                    getSchemaOrRef(type, Visibility.Read);
                }
            };
            const skipSubNamespaces = isGlobalNamespace(program, serviceNamespace);
            navigateTypesInNamespace(serviceNamespace, {
                model: addSchema,
                scalar: addSchema,
                enum: addSchema,
                union: addSchema,
            }, { skipSubNamespaces });
            processSchemas();
        }
    }
    function emitTags() {
        for (const tag of tags) {
            root.tags.push({ name: tag });
        }
    }
    async function loadExamples(version) {
        var _a;
        if (options.examplesDirectory) {
            const exampleDir = version
                ? resolvePath(options.examplesDirectory, version)
                : resolvePath(options.examplesDirectory);
            try {
                if (!(await program.host.stat(exampleDir)).isDirectory())
                    return;
            }
            catch (err) {
                reportDiagnostic(program, {
                    code: "example-loading",
                    messageId: "noDirectory",
                    format: { directory: exampleDir },
                    target: NoTarget,
                });
                return;
            }
            const exampleFiles = await program.host.readDir(exampleDir);
            for (const fileName of exampleFiles) {
                try {
                    const exampleFile = await program.host.readFile(resolvePath(exampleDir, fileName));
                    const example = JSON.parse(exampleFile.text);
                    if (!example.operationId || !example.title) {
                        reportDiagnostic(program, {
                            code: "example-loading",
                            messageId: "noOperationId",
                            format: { filename: fileName },
                            target: NoTarget,
                        });
                        continue;
                    }
                    if (!operationExamplesMap.has(example.operationId)) {
                        operationExamplesMap.set(example.operationId, {});
                    }
                    const examples = operationExamplesMap.get(example.operationId);
                    if (example.title in examples) {
                        reportDiagnostic(program, {
                            code: "duplicate-example-file",
                            target: NoTarget,
                            format: {
                                filename: fileName,
                                operationId: example.operationId,
                                title: example.title,
                            },
                        });
                    }
                    examples[example.title] = fileName;
                }
                catch (err) {
                    reportDiagnostic(program, {
                        code: "example-loading",
                        messageId: "default",
                        format: { filename: fileName, error: (_a = err === null || err === void 0 ? void 0 : err.toString()) !== null && _a !== void 0 ? _a : "" },
                        target: NoTarget,
                    });
                }
            }
        }
    }
    function getSchemaForType(type, visibility) {
        const builtinType = getSchemaForLiterals(type);
        if (builtinType !== undefined) {
            return builtinType;
        }
        switch (type.kind) {
            case "Intrinsic":
                return getSchemaForIntrinsicType(type);
            case "Model":
                return getSchemaForModel(type, visibility);
            case "ModelProperty":
                return getSchemaForType(type.type, visibility);
            case "Scalar":
                return getSchemaForScalar(type);
            case "Union":
                return getSchemaForUnion(type, visibility);
            case "UnionVariant":
                return getSchemaForUnionVariant(type, visibility);
            case "Enum":
                return getSchemaForEnum(type);
            case "Tuple":
                return { type: "array", items: {} };
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.kind },
            target: type,
        });
        return undefined;
    }
    function getSchemaForIntrinsicType(type) {
        switch (type.name) {
            case "unknown":
                return {};
        }
        reportDiagnostic(program, {
            code: "invalid-schema",
            format: { type: type.name },
            target: type,
        });
        return {};
    }
    function getSchemaForEnum(e) {
        var _a;
        const values = [];
        if (e.members.size === 0) {
            reportUnsupportedUnion("empty");
            return {};
        }
        const type = getEnumMemberType(e.members.values().next().value);
        for (const option of e.members.values()) {
            if (type !== getEnumMemberType(option)) {
                reportUnsupportedUnion();
                continue;
            }
            else {
                values.push((_a = option.value) !== null && _a !== void 0 ? _a : option.name);
            }
        }
        const schema = { type, description: getDoc(program, e) };
        if (values.length > 0) {
            schema.enum = values;
            addXMSEnum(e, schema);
        }
        if (options.useReadOnlyStatusSchema) {
            const [values, _] = extractLroStates(program, e);
            if (values !== undefined) {
                schema.readOnly = true;
            }
        }
        return schema;
        function getEnumMemberType(member) {
            if (typeof member.value === "number") {
                return "number";
            }
            return "string";
        }
        function reportUnsupportedUnion(messageId = "default") {
            reportDiagnostic(program, { code: "union-unsupported", messageId, target: e });
        }
    }
    function getSchemaForUnionEnum(union, e) {
        const values = [];
        let foundCustom = false;
        for (const [name, member] of e.flattenedMembers.entries()) {
            const description = getDoc(program, member.variant);
            values.push({
                name: typeof name === "string" ? name : `${member.value}`,
                value: member.value,
                description,
            });
            if (description || typeof name === "string") {
                foundCustom = true;
            }
        }
        const schema = {
            type: e.kind,
            enum: [...e.flattenedMembers.values()].map((x) => x.value),
            "x-ms-enum": {
                name: union.name,
                modelAsString: e.open,
            },
        };
        if (foundCustom) {
            schema["x-ms-enum"].values = values;
        }
        if (e.nullable) {
            schema["x-nullable"] = true;
        }
        return schema;
    }
    function getSchemaForUnion(union, visibility) {
        const [asEnum, _] = getUnionAsEnum(union);
        if (asEnum) {
            return getSchemaForUnionEnum(union, asEnum);
        }
        const nonNullOptions = [...union.variants.values()]
            .map((x) => x.type)
            .filter((t) => !isNullType(t));
        const nullable = union.variants.size !== nonNullOptions.length;
        if (nonNullOptions.length === 0) {
            reportDiagnostic(program, { code: "union-null", target: union });
            return {};
        }
        if (nonNullOptions.length === 1) {
            const type = nonNullOptions[0];
            // Get the schema for the model type
            const schema = getSchemaOrRef(type, visibility);
            if (schema.$ref) {
                if (type.kind === "Model") {
                    return { type: "object", allOf: [schema], "x-nullable": nullable };
                }
                else {
                    return { ...schema, "x-nullable": nullable };
                }
            }
            else {
                schema["x-nullable"] = nullable;
                return schema;
            }
        }
        else {
            reportDiagnostic(program, {
                code: "union-unsupported",
                target: union,
            });
            return {};
        }
    }
    function ifArrayItemContainsIdentifier(program, array) {
        var _a;
        if (((_a = array.indexer.value) === null || _a === void 0 ? void 0 : _a.kind) !== "Model") {
            return true;
        }
        return (getExtensions(program, array).has("x-ms-identifiers") ||
            getProperty(array.indexer.value, "id"));
    }
    function getSchemaForUnionVariant(variant, visibility) {
        return getSchemaForType(variant.type, visibility);
    }
    function getDefaultValue(type) {
        var _a;
        switch (type.kind) {
            case "String":
                return type.value;
            case "Number":
                return type.value;
            case "Boolean":
                return type.value;
            case "Tuple":
                return type.values.map(getDefaultValue);
            case "EnumMember":
                return (_a = type.value) !== null && _a !== void 0 ? _a : type.name;
            case "Intrinsic":
                return isNullType(type)
                    ? null
                    : reportDiagnostic(program, {
                        code: "invalid-default",
                        format: { type: type.kind },
                        target: type,
                    });
            default:
                reportDiagnostic(program, {
                    code: "invalid-default",
                    format: { type: type.kind },
                    target: type,
                });
        }
    }
    function includeDerivedModel(model) {
        var _a, _b;
        return (!isTemplateDeclaration(model) &&
            (((_a = model.templateMapper) === null || _a === void 0 ? void 0 : _a.args) === undefined ||
                ((_b = model.templateMapper) === null || _b === void 0 ? void 0 : _b.args.length) === 0 ||
                model.derivedModels.length > 0));
    }
    function getSchemaForModel(model, visibility) {
        const array = getArrayType(model, visibility);
        if (array) {
            return array;
        }
        const modelSchema = {
            type: "object",
            description: getDoc(program, model),
        };
        if (model.baseModel) {
            const discriminator = getDiscriminator(program, model.baseModel);
            if (discriminator) {
                const prop = getProperty(model, discriminator.propertyName);
                if (prop) {
                    const values = getStringValues(prop.type);
                    if (values.length === 1) {
                        const extensions = getExtensions(program, model);
                        if (!extensions.has("x-ms-discriminator-value")) {
                            modelSchema["x-ms-discriminator-value"] = values[0];
                        }
                    }
                }
            }
        }
        const properties = {};
        if (isRecordModelType(program, model)) {
            modelSchema.additionalProperties = getSchemaOrRef(model.indexer.value, visibility);
        }
        const derivedModels = model.derivedModels.filter(includeDerivedModel);
        // getSchemaOrRef on all children to push them into components.schemas
        for (const child of derivedModels) {
            getSchemaOrRef(child, visibility);
        }
        const discriminator = getDiscriminator(program, model);
        if (discriminator) {
            const { propertyName } = discriminator;
            modelSchema.discriminator = propertyName;
            // Push discriminator into base type, but only if it is not already there
            if (!model.properties.get(propertyName)) {
                properties[propertyName] = {
                    type: "string",
                    description: `Discriminator property for ${model.name}.`,
                };
                modelSchema.required = [propertyName];
            }
        }
        applyExternalDocs(model, modelSchema);
        for (const prop of model.properties.values()) {
            if (!metadataInfo.isPayloadProperty(prop, visibility)) {
                continue;
            }
            if (isNeverType(prop.type)) {
                // If the property has a type of 'never', don't include it in the schema
                continue;
            }
            const jsonName = getJsonName(prop);
            const clientName = clientView.getProjectedName(prop);
            const description = getDoc(program, prop);
            // if this property is a discriminator property, remove it to keep autorest validation happy
            if (model.baseModel) {
                const { propertyName } = getDiscriminator(program, model.baseModel) || {};
                if (jsonName === propertyName) {
                    continue;
                }
            }
            if (!metadataInfo.isOptional(prop, visibility) || prop.name === (discriminator === null || discriminator === void 0 ? void 0 : discriminator.propertyName)) {
                if (!modelSchema.required) {
                    modelSchema.required = [];
                }
                modelSchema.required.push(jsonName);
            }
            // Apply decorators on the property to the type's schema
            properties[jsonName] = resolveProperty(prop, visibility);
            const property = properties[jsonName];
            if (jsonName !== clientName) {
                property["x-ms-client-name"] = clientName;
            }
            if (description) {
                property.description = description;
            }
            if (prop.default) {
                property.default = getDefaultValue(prop.default);
            }
            if (isReadonlyProperty(program, prop)) {
                property.readOnly = true;
            }
            else {
                const vis = getVisibility(program, prop);
                if (vis) {
                    const mutability = [];
                    if (vis.includes("read")) {
                        mutability.push("read");
                    }
                    if (vis.includes("update")) {
                        mutability.push("update");
                    }
                    if (vis.includes("create")) {
                        mutability.push("create");
                    }
                    if (mutability.length > 0) {
                        property["x-ms-mutability"] = mutability;
                    }
                }
            }
            // Attach any additional OpenAPI extensions
            attachExtensions(prop, property);
        }
        // Special case: if a model type extends a single *templated* base type and
        // has no properties of its own, absorb the definition of the base model
        // into this schema definition.  The assumption here is that any model type
        // defined like this is just meant to rename the underlying instance of a
        // templated type.
        if (model.baseModel &&
            isTemplateDeclarationOrInstance(model.baseModel) &&
            Object.keys(properties).length === 0) {
            // Take the base model schema but carry across the documentation property
            // that we set before
            const baseSchema = getSchemaForType(model.baseModel, visibility);
            Object.assign(modelSchema, baseSchema, { description: modelSchema.description });
        }
        else if (model.baseModel) {
            const baseSchema = getSchemaOrRef(model.baseModel, visibility);
            modelSchema.allOf = [baseSchema];
        }
        if (Object.keys(properties).length > 0) {
            modelSchema.properties = properties;
        }
        // Attach any OpenAPI extensions
        attachExtensions(model, modelSchema);
        return modelSchema;
    }
    function canSharePropertyUsingReadonlyOrXMSMutability(prop) {
        const sharedVisibilities = ["read", "create", "update", "write"];
        const visibilities = getVisibility(program, prop);
        if (visibilities) {
            for (const visibility of visibilities) {
                if (!sharedVisibilities.includes(visibility)) {
                    return false;
                }
            }
        }
        return true;
    }
    function resolveProperty(prop, visibility) {
        const propSchema = getSchemaOrRef(prop.type, visibility);
        return applyIntrinsicDecorators(prop, propSchema);
    }
    function attachExtensions(type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(program, type);
        if (getAsEmbeddingVector(program, type) !== undefined) {
            emitObject["x-ms-embedding-vector"] = true;
        }
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    // Return any string literal values for type
    function getStringValues(type) {
        var _a;
        switch (type.kind) {
            case "String":
                return [type.value];
            case "Union":
                return [...type.variants.values()].flatMap((x) => getStringValues(x.type)).filter((x) => x);
            case "EnumMember":
                return typeof type.value !== "number" ? [(_a = type.value) !== null && _a !== void 0 ? _a : type.name] : [];
            case "UnionVariant":
                return getStringValues(type.type);
            default:
                return [];
        }
    }
    function applyIntrinsicDecorators(typespecType, target) {
        const newTarget = { ...target };
        const docStr = getDoc(program, typespecType);
        const isString = typespecType.kind !== "Model" && isStringType(program, getPropertyType(typespecType));
        const isNumeric = typespecType.kind !== "Model" && isNumericType(program, getPropertyType(typespecType));
        if (docStr) {
            newTarget.description = docStr;
        }
        const formatStr = getFormat(program, typespecType);
        if (isString && formatStr) {
            const allowedStringFormats = [
                "char",
                "binary",
                "byte",
                "certificate",
                "date",
                "time",
                "date-time",
                "date-time-rfc1123",
                "date-time-rfc7231",
                "duration",
                "password",
                "uuid",
                "base64url",
                "uri",
                "url",
                "arm-id",
            ];
            if (!allowedStringFormats.includes(formatStr.toLowerCase())) {
                reportDiagnostic(program, {
                    code: "invalid-format",
                    format: { schema: "string", format: formatStr },
                    target: typespecType,
                });
            }
            else {
                newTarget.format = formatStr;
            }
        }
        const pattern = getPattern(program, typespecType);
        if (isString && pattern) {
            newTarget.pattern = pattern;
        }
        const minLength = getMinLength(program, typespecType);
        if (isString && minLength !== undefined) {
            newTarget.minLength = minLength;
        }
        const maxLength = getMaxLength(program, typespecType);
        if (isString && maxLength !== undefined) {
            newTarget.maxLength = maxLength;
        }
        const minValue = getMinValue(program, typespecType);
        if (isNumeric && minValue !== undefined) {
            newTarget.minimum = minValue;
        }
        const maxValue = getMaxValue(program, typespecType);
        if (isNumeric && maxValue !== undefined) {
            newTarget.maximum = maxValue;
        }
        const minItems = getMinItems(program, typespecType);
        if (!target.minItems && minItems !== undefined) {
            newTarget.minItems = minItems;
        }
        const maxItems = getMaxItems(program, typespecType);
        if (!target.maxItems && maxItems !== undefined) {
            newTarget.maxItems = maxItems;
        }
        if (isSecret(program, typespecType)) {
            newTarget.format = "password";
            newTarget["x-ms-secret"] = true;
        }
        if (isString) {
            const values = getKnownValues(program, typespecType);
            if (values) {
                const enumSchema = { ...newTarget, ...getSchemaForEnum(values) };
                enumSchema["x-ms-enum"].modelAsString = true;
                enumSchema["x-ms-enum"].name = getPropertyType(typespecType).name;
                return enumSchema;
            }
        }
        attachExtensions(typespecType, newTarget);
        return typespecType.kind === "Model" ? newTarget : applyEncoding(typespecType, newTarget);
    }
    function applyEncoding(typespecType, target) {
        const encodeData = getEncode(program, typespecType);
        if (encodeData) {
            const newTarget = { ...target };
            const newType = getSchemaForScalar(encodeData.type);
            newTarget.type = newType.type;
            // If the target already has a format it takes priority. (e.g. int32)
            newTarget.format = mergeFormatAndEncoding(newTarget.format, encodeData.encoding, newType.format);
            return newTarget;
        }
        return target;
    }
    function mergeFormatAndEncoding(format, encoding, encodeAsFormat) {
        switch (format) {
            case undefined:
                return encodeAsFormat !== null && encodeAsFormat !== void 0 ? encodeAsFormat : encoding;
            case "date-time":
                switch (encoding) {
                    case "rfc3339":
                        return "date-time";
                    case "unixTimestamp":
                        return "unixtime";
                    case "rfc7231":
                        return "date-time-rfc7231";
                    default:
                        return encoding;
                }
            case "duration":
                switch (encoding) {
                    case "ISO8601":
                        return "duration";
                    default:
                        return encodeAsFormat !== null && encodeAsFormat !== void 0 ? encodeAsFormat : encoding;
                }
            default:
                return encodeAsFormat !== null && encodeAsFormat !== void 0 ? encodeAsFormat : encoding;
        }
    }
    function applyExternalDocs(typespecType, target) {
        const externalDocs = getExternalDocs(program, typespecType);
        if (externalDocs) {
            target.externalDocs = externalDocs;
        }
    }
    function addXMSEnum(type, schema) {
        var _a;
        if (type.node && type.node.parent && type.node.parent.kind === SyntaxKind.ModelStatement) {
            schema["x-ms-enum"] = {
                name: type.node.parent.id.sv,
                modelAsString: true,
            };
        }
        else if (type.kind === "String") {
            schema["x-ms-enum"] = {
                modelAsString: false,
            };
        }
        else if (type.kind === "Enum") {
            schema["x-ms-enum"] = {
                name: type.name,
                modelAsString: isFixed(program, type) ? false : true,
            };
            const values = [];
            let foundCustom = false;
            for (const member of type.members.values()) {
                const description = getDoc(program, member);
                values.push({
                    name: member.name,
                    value: (_a = member.value) !== null && _a !== void 0 ? _a : member.name,
                    description,
                });
                if (description || member.value !== undefined) {
                    foundCustom = true;
                }
            }
            if (foundCustom) {
                schema["x-ms-enum"].values = values;
            }
        }
        return schema;
    }
    function getSchemaForStringTemplate(stringTemplate) {
        const [value, diagnostics] = stringTemplateToString(stringTemplate);
        if (diagnostics.length > 0) {
            program.reportDiagnostics(diagnostics.map((x) => ({ ...x, severity: "warning" })));
            return { type: "string" };
        }
        return { type: "string", enum: [value] };
    }
    function getSchemaForLiterals(typespecType) {
        switch (typespecType.kind) {
            case "Number":
                return { type: "number", enum: [typespecType.value] };
            case "String":
                return addXMSEnum(typespecType, { type: "string", enum: [typespecType.value] });
            case "Boolean":
                return { type: "boolean", enum: [typespecType.value] };
            default:
                return undefined;
        }
    }
    /**
     * If the model is an array model return the OpenAPI2Schema for the array type.
     */
    function getArrayType(typespecType, visibility) {
        if (isArrayModelType(program, typespecType)) {
            const array = {
                type: "array",
                items: getSchemaOrRef(typespecType.indexer.value, visibility | Visibility.Item),
            };
            if (!ifArrayItemContainsIdentifier(program, typespecType)) {
                array["x-ms-identifiers"] = [];
            }
            return applyIntrinsicDecorators(typespecType, array);
        }
        return undefined;
    }
    function getSchemaForScalar(scalar) {
        let result = {};
        const isStd = program.checker.isStdType(scalar);
        if (isStd) {
            result = getSchemaForStdScalars(scalar);
        }
        else if (scalar.baseScalar) {
            result = getSchemaForScalar(scalar.baseScalar);
        }
        const withDecorators = applyIntrinsicDecorators(scalar, result);
        if (isStd) {
            // Standard types are going to be inlined in the spec and we don't want the description of the scalar to show up
            delete withDecorators.description;
        }
        return withDecorators;
    }
    function getSchemaForStdScalars(scalar) {
        function reportNonspecificScalar(scalarName, chosenScalarName) {
            reportDiagnostic(program, {
                code: "nonspecific-scalar",
                format: { type: scalarName, chosenType: chosenScalarName },
                target: scalar,
            });
        }
        switch (scalar.name) {
            case "bytes":
                return { type: "string", format: "byte" };
            case "numeric":
                reportNonspecificScalar("numeric", "int64");
                return { type: "integer", format: "int64" };
            case "integer":
                reportNonspecificScalar("integer", "int64");
                return { type: "integer", format: "int64" };
            case "int8":
                return { type: "integer", format: "int8" };
            case "int16":
                return { type: "integer", format: "int16" };
            case "int32":
                return { type: "integer", format: "int32" };
            case "int64":
                return { type: "integer", format: "int64" };
            case "safeint":
                return { type: "integer", format: "int64" };
            case "uint8":
                return { type: "integer", format: "uint8" };
            case "uint16":
                return { type: "integer", format: "uint16" };
            case "uint32":
                return { type: "integer", format: "uint32" };
            case "uint64":
                return { type: "integer", format: "uint64" };
            case "float":
                reportNonspecificScalar("float", "float64");
                return { type: "number" };
            case "float64":
                return { type: "number", format: "double" };
            case "float32":
                return { type: "number", format: "float" };
            case "decimal":
                return { type: "number", format: "decimal" };
            case "decimal128":
                return { type: "number", format: "decimal" };
            case "string":
                return { type: "string" };
            case "boolean":
                return { type: "boolean" };
            case "plainDate":
                return { type: "string", format: "date" };
            case "utcDateTime":
            case "offsetDateTime":
                return { type: "string", format: "date-time" };
            case "plainTime":
                return { type: "string", format: "time" };
            case "duration":
                return { type: "string", format: "duration" };
            case "url":
                return { type: "string", format: "uri" };
            default:
                const _assertNever = scalar.name;
                return {};
        }
    }
    function processAuth(serviceNamespace) {
        const authentication = getAuthentication(program, serviceNamespace);
        if (authentication) {
            return processServiceAuthentication(authentication, serviceNamespace);
        }
        return undefined;
    }
    function processServiceAuthentication(authentication, serviceNamespace) {
        const oaiSchemes = {};
        const security = [];
        for (const option of authentication.options) {
            const oai3SecurityOption = {};
            for (const scheme of option.schemes) {
                const result = getOpenAPI2Scheme(scheme, serviceNamespace);
                if (result !== undefined) {
                    const [oaiScheme, scopes] = result;
                    oaiSchemes[scheme.id] = oaiScheme;
                    oai3SecurityOption[scheme.id] = scopes;
                }
            }
            if (Object.keys(oai3SecurityOption).length > 0) {
                security.push(oai3SecurityOption);
            }
        }
        return { securitySchemes: oaiSchemes, security };
    }
    function getOpenAPI2Scheme(auth, serviceNamespace) {
        switch (auth.type) {
            case "http":
                if (auth.scheme !== "basic") {
                    reportDiagnostic(program, {
                        code: "unsupported-http-auth-scheme",
                        target: serviceNamespace,
                        format: { scheme: auth.scheme },
                    });
                    return undefined;
                }
                return [{ type: "basic", description: auth.description }, []];
            case "apiKey":
                if (auth.in === "cookie") {
                    return undefined;
                }
                return [
                    { type: "apiKey", description: auth.description, in: auth.in, name: auth.name },
                    [],
                ];
            case "oauth2":
                const flow = auth.flows[0];
                if (flow === undefined) {
                    return undefined;
                }
                const oaiFlowName = getOpenAPI2Flow(flow.type);
                return [
                    {
                        type: "oauth2",
                        description: auth.description,
                        flow: oaiFlowName,
                        authorizationUrl: flow.authorizationUrl,
                        tokenUrl: flow.tokenUrl,
                        scopes: Object.fromEntries(flow.scopes.map((x) => { var _a; return [x.value, (_a = x.description) !== null && _a !== void 0 ? _a : ""]; })),
                    },
                    flow.scopes.map((x) => x.value),
                ];
            default:
                const _assertNever = auth;
                compilerAssert(false, "Unreachable");
        }
    }
    function getOpenAPI2Flow(flow) {
        switch (flow) {
            case "authorizationCode":
                return "accessCode";
            case "clientCredentials":
                return "application";
            case "implicit":
                return "implicit";
            case "password":
                return "password";
            default:
                const _assertNever = flow;
                compilerAssert(false, "Unreachable");
        }
    }
}
function prettierOutput(output) {
    return output + "\n";
}
class ErrorTypeFoundError extends Error {
    constructor() {
        super("Error type found in evaluated TypeSpec output");
    }
}
export function sortOpenAPIDocument(doc) {
    // Doing this to make sure the classes with toJSON are resolved.
    const unsorted = JSON.parse(JSON.stringify(doc));
    const sorted = sortWithJsonSchema(unsorted, AutorestOpenAPISchema, "#/$defs/AutorestOpenAPISchema");
    return sorted;
}
function resolveOutputFile(service, multipleServices, options, version) {
    var _a;
    const azureResourceProviderFolder = options.azureResourceProviderFolder;
    if (azureResourceProviderFolder) {
        version = (_a = version !== null && version !== void 0 ? version : service.version) !== null && _a !== void 0 ? _a : "0000-00-00";
    }
    const interpolated = interpolatePath(options.outputFile, {
        "azure-resource-provider-folder": azureResourceProviderFolder,
        "service-name": multipleServices || azureResourceProviderFolder
            ? getNamespaceFullName(service.type)
            : undefined,
        "version-status": azureResourceProviderFolder
            ? (version === null || version === void 0 ? void 0 : version.includes("preview"))
                ? "preview"
                : "stable"
            : undefined,
        version,
    });
    return resolvePath(options.outputDir, interpolated);
}
//# sourceMappingURL=openapi.js.map