var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JsonSchemaReader_doc, _JsonSchemaReader_defs;
export function sortWithJsonSchema(value, jsonSchema, ref) {
    const schema = ref ? resolveJsonRef(ref, jsonSchema) : jsonSchema;
    return internalSort(value, schema, new JsonSchemaReader(jsonSchema));
}
function internalSort(value, relativeSchema, reader) {
    if (typeof value !== "object" || value === null) {
        return value;
    }
    const resolvedRelativeSchema = relativeSchema && resolveSchema(relativeSchema, reader);
    if (Array.isArray(value)) {
        const itemsSchema = (resolvedRelativeSchema === null || resolvedRelativeSchema === void 0 ? void 0 : resolvedRelativeSchema.type) === "array" ? resolvedRelativeSchema.items : undefined;
        return value.map((x) => internalSort(x, itemsSchema, reader));
    }
    const objectSchema = resolvedRelativeSchema;
    const properties = (objectSchema === null || objectSchema === void 0 ? void 0 : objectSchema.properties) && Object.keys(objectSchema.properties);
    const keys = Object.keys(value);
    const ordering = objectSchema === null || objectSchema === void 0 ? void 0 : objectSchema["x-ordering"];
    if (ordering === "url") {
        keys.sort(compareUrl);
    }
    else if (ordering !== "keep") {
        keys.sort((a, b) => {
            if (properties) {
                const aIndex = properties.indexOf(a);
                const bIndex = properties.indexOf(b);
                if (aIndex !== -1 && bIndex !== -1) {
                    return aIndex - bIndex;
                }
                else if (aIndex !== -1) {
                    return -1;
                }
                else if (bIndex !== -1) {
                    return 1;
                }
            }
            return defaultCompare(a, b);
        });
    }
    return keys.reduce((o, key) => {
        var _a, _b, _c;
        const v = value[key];
        const propertySchema = (_c = (_b = (_a = objectSchema === null || objectSchema === void 0 ? void 0 : objectSchema.properties) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : resolvePatternProperties(key, objectSchema === null || objectSchema === void 0 ? void 0 : objectSchema.patternProperties)) !== null && _c !== void 0 ? _c : resolveAdditionalProperties(objectSchema === null || objectSchema === void 0 ? void 0 : objectSchema.additionalProperties);
        if (propertySchema !== undefined) {
            o[key] = internalSort(v, propertySchema, reader);
        }
        else {
            o[key] = v;
        }
        return o;
    }, {});
}
/**
 * Default sort implementation for deterministic sorting.
 */
function defaultCompare(a, b) {
    return +(a > b) || -(b > a);
}
/** Sort urls in a specific way so path with field show up before a fixed segment. */
function compareUrl(leftPath, rightPath) {
    const leftParts = leftPath.split("/").slice(1);
    const rightParts = rightPath.split("/").slice(1);
    for (let i = 0; i < Math.max(leftParts.length, rightParts.length); i++) {
        // Have we exhausted the path parts of one of them?
        if (i === leftParts.length)
            return -1;
        if (i === rightParts.length)
            return 1;
        // Does this segment represent a path parameter (field) on either side?
        const leftIsField = leftParts[i][0] === "{";
        const rightIsField = rightParts[i][0] === "{";
        // If both are fields, try the next part regardless of the field name
        // since the field ordering is all that really matters
        if (leftIsField && rightIsField) {
            continue;
        }
        // If only one is a field, it automatically wins
        if (leftIsField || rightIsField) {
            return leftIsField ? -1 : 1;
        }
        // Sort lexicographically
        const result = defaultCompare(leftParts[i], rightParts[i]);
        if (result !== 0) {
            return result;
        }
    }
    // Must be the same
    return 0;
}
function resolveSchema(schema, reader) {
    if ("$ref" in schema) {
        return reader.resolveRef(schema.$ref);
    }
    else {
        return schema;
    }
}
function resolveJsonRef(ref, baseSchema) {
    const [file, path] = ref.split("#");
    if (file !== "") {
        throw new Error(`JsonSchemaSorter: Not supporting cross file ref: "${ref}".`);
    }
    const segments = path.split("/");
    let current = baseSchema;
    for (const segment of segments.slice(1)) {
        if (segment in current) {
            current = current[segment];
        }
        else {
            throw new Error(`JsonSchemaSorter: ref "${ref}" is invalid`);
        }
    }
    return current;
}
function resolvePatternProperties(key, patternProperties) {
    if (patternProperties === undefined) {
        return undefined;
    }
    for (const [pattern, schema] of Object.entries(patternProperties)) {
        if (key.match(pattern)) {
            return schema;
        }
    }
    return undefined;
}
function resolveAdditionalProperties(additionalProperties) {
    if (typeof additionalProperties === "boolean") {
        return undefined;
    }
    return additionalProperties;
}
class JsonSchemaReader {
    constructor(doc) {
        _JsonSchemaReader_doc.set(this, void 0);
        _JsonSchemaReader_defs.set(this, new Map());
        __classPrivateFieldSet(this, _JsonSchemaReader_doc, doc, "f");
        if (doc.$defs) {
            for (const value of Object.values(doc.$defs)) {
                if ("$id" in value && value.$id) {
                    __classPrivateFieldGet(this, _JsonSchemaReader_defs, "f").set(value.$id, value);
                }
            }
        }
    }
    resolveRef(ref) {
        if (ref.includes("#")) {
            return resolveJsonRef(ref, __classPrivateFieldGet(this, _JsonSchemaReader_doc, "f"));
        }
        else {
            const schema = __classPrivateFieldGet(this, _JsonSchemaReader_defs, "f").get(ref);
            if (schema === undefined) {
                throw new Error(`JsonSchemaSorter: Cannot find schema with $id ${ref}`);
            }
            if ("$ref" in schema) {
                return this.resolveRef(schema.$ref);
            }
            else {
                return schema;
            }
        }
    }
}
_JsonSchemaReader_doc = new WeakMap(), _JsonSchemaReader_defs = new WeakMap();
//# sourceMappingURL=sorter.js.map