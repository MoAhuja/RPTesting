import { createRule, paramMessage } from "@typespec/compiler";
import { getSegment } from "@typespec/rest";
import { getDecoratorParam, isInternalTypeSpec, isResource, isValidKey } from "./utils.js";
export const armResourcePathInvalidCharsRule = createRule({
    name: "arm-resource-path-segment-invalid-chars",
    severity: "warning",
    description: "Arm resource name must contain only alphanumeric characters.",
    messages: {
        default: paramMessage `'${"segment"}' is an invalid path segment. Segments may start with a separator must consist of alphanumeric characters or dashes, starting with a lower case letter.`,
    },
    create(context) {
        return {
            model: (model) => {
                var _a, _b;
                if (!isInternalTypeSpec(context.program, model) &&
                    isResource(model) &&
                    model.properties.has("name")) {
                    const nameProperty = model.properties.get("name");
                    const separator = "/";
                    const segment = getSegment(context.program, nameProperty);
                    if (segment !== undefined && !isValidPathSegment(segment, separator)) {
                        context.reportDiagnostic({
                            format: { segment: segment },
                            target: (_b = (_a = getDecoratorParam(nameProperty, "segment")) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : nameProperty,
                        });
                    }
                }
            },
        };
    },
});
function isValidPathSegment(path, separator) {
    if (path.startsWith(separator))
        path = path.replace(separator, "");
    return isValidKey(path);
}
//# sourceMappingURL=arm-resource-path-invalid-chars.js.map