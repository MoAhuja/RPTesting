import { DecoratorContext, Interface, Model, Operation, Program } from "@typespec/compiler";
import { ArmResourceOperations } from "./operations.js";
export type ArmResourceKind = "Tracked" | "Proxy" | "Extension";
/**
 * Interface for ARM resource detail base.
 *
 * @interface
 */
export interface ArmResourceDetailsBase {
    name: string;
    kind: ArmResourceKind;
    armProviderNamespace: string;
    keyName: string;
    collectionName: string;
    typespecType: Model;
}
export interface ArmResourceDetails extends ArmResourceDetailsBase {
    operations: ArmResourceOperations;
    resourceTypePath?: string;
}
/**
 *  This function returns fully-resolved details about all ARM resources
 *  registered in the TypeSpec document including operations and their details.
 *
 *  It should only be called after the full TypeSpec document has been compiled
 *  so that operation route details are certain to be present.
 */
export declare function getArmResources(program: Program): ArmResourceDetails[];
export { getArmResource } from "./private.decorators.js";
export declare function getArmResourceInfo(program: Program, resourceType: Model): ArmResourceDetails | undefined;
export declare function getArmResourceKind(resourceType: Model): ArmResourceKind | undefined;
/**
 * This decorator is used to identify interfaces containing resource operations.
 * When applied, it marks the interface with the `@autoRoute` decorator so that
 * all of its contained operations will have their routes generated
 * automatically.
 *
 * It also adds a `@tag` decorator bearing the name of the interface so that all
 * of the operations will be grouped based on the interface name in generated
 * clients.
 */
export declare function $armResourceOperations(context: DecoratorContext, interfaceType: Interface): void;
/**
 * This decorator is used to mark a resource type as a "singleton", a type with
 * only one instance.  The standard set of resource operations can be applied to
 * such a resource type, they will generate the correct routes and parameter
 * lists.
 */
export declare function $singleton(context: DecoratorContext, resourceType: Model, keyValue?: string): void;
export declare function isSingletonResource(program: Program, resourceType: Model): boolean;
export declare function getSingletonResourceKey(program: Program, resourceType: Model): string | undefined;
export declare enum ResourceBaseType {
    Tenant = "Tenant",
    Subscription = "Subscription",
    Location = "Location",
    ResourceGroup = "ResourceGroup",
    Extension = "Extension"
}
export declare function $tenantResource(context: DecoratorContext, entity: Model): void;
export declare function $subscriptionResource(context: DecoratorContext, entity: Model): void;
export declare function $locationResource(context: DecoratorContext, entity: Model): void;
export declare function $resourceGroupResource(context: DecoratorContext, entity: Model): void;
export declare function $extensionResource(context: DecoratorContext, entity: Model): void;
export declare function $armProviderNameValue(context: DecoratorContext, entity: Operation): void;
export declare function getResourceBaseType(program: Program, resource: Model): ResourceBaseType;
export declare function resolveResourceBaseType(type?: string | undefined): ResourceBaseType;
//# sourceMappingURL=resource.d.ts.map