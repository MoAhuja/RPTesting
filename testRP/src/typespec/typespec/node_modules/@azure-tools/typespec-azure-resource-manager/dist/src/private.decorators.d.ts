import { DecoratorContext, Enum, EnumMember, Interface, Model, ModelProperty, Operation, Program, Tuple } from "@typespec/compiler";
import { ArmResourceDetails } from "./resource.js";
export declare const namespace = "Azure.ResourceManager.Private";
export declare function $omitIfEmpty(context: DecoratorContext, entity: Model, propertyName: string): void;
export declare function $resourceBaseParametersOf(context: DecoratorContext, entity: Model, resourceType: Model): void;
export declare function $resourceParameterBaseFor(context: DecoratorContext, entity: ModelProperty, values: Tuple): void;
export declare function getResourceParameterBases(program: Program, property: ModelProperty): string[] | undefined;
export declare function isResourceParameterBaseFor(program: Program, property: ModelProperty, resourceBaseType: string): boolean;
/**
 * Refer an model property to be a common ARM parameter
 * @param {DecoratorContext} context DecoratorContext object
 * @param {Type} entity Decorator target type. Must be `Model`
 * @param {string?} definitionName Optional definition name
 * @param {string?} version Optional version
 * @param {string?} referenceFile Optional common file path
 * @returns void
 */
export declare function $armCommonParameter(context: DecoratorContext, entity: ModelProperty, parameterName?: string, version?: string | EnumMember | Model, referenceFile?: string): void;
/**
 * Using ARM common definition for a Model
 * @param {DecoratorContext} context DecoratorContext object
 * @param {Type} entity Decorator target type. Must be `Model`
 * @param {string?} definitionName Optional definition name
 * @param {string?} version Optional version
 * @param {string?} referenceFile Optional common file path
 * @returns {void}
 */
export declare function $armCommonDefinition(context: DecoratorContext, entity: Model, definitionName?: string, version?: string | EnumMember | Model, referenceFile?: string): void;
/**
 * This decorator dynamically assigns the serviceNamespace from the containing
 * namespace to the string literal value of the path parameter to which this
 * decorator is applied.  Its purpose is to dynamically insert the provider
 * namespace (e.g. 'Microsoft.CodeSigning') into the path parameter list.
 * @param {DecoratorContext} context DecoratorContext
 * @param {Type} target Target of this decorator. Must be a string `ModelProperty`.
 * @param {Type} resourceType Must be a `Model`.
 */
export declare function $assignProviderNameValue(context: DecoratorContext, target: ModelProperty, resourceType: Model): void;
/**
 * Update the ARM provider namespace for a given entity.
 * @param {DecoratorContext} context DecoratorContext
 * @param {Type} entity Entity to set namespace. Must be a `Operation`.
 * @returns
 */
export declare function $armUpdateProviderNamespace(context: DecoratorContext, entity: Operation): void;
/**
 * Check if an interface is extending the Azure.ResourceManager.Operations interface.
 */
export declare function isArmOperationsListInterface(program: Program, type: Interface): boolean;
/**
 * This decorator is used to identify ARM resource types and extract their
 * metadata.  It is *not* meant to be used directly by a spec author, it instead
 * gets implicitly applied when the spec author defines a model type in this form:
 *
 *   `model Server is TrackedResource<ServerProperties>;`
 *
 * The `TrackedResource<T>` type (and other associated base types) use the @armResource
 * decorator, so it also gets applied to the type which absorbs the `TrackedResource<T>`
 * definition by using the `is` keyword.
 */
export declare function $armResourceInternal(context: DecoratorContext, resourceType: Model, propertiesType: Model): void;
export declare function listArmResources(program: Program): ArmResourceDetails[];
export declare function getArmResource(program: Program, resourceType: Model): ArmResourceDetails | undefined;
export declare function $armCommonTypesVersions(context: DecoratorContext, enumType: Enum): void;
//# sourceMappingURL=private.decorators.d.ts.map