import { getArmProviderNamespace, getArmResource, getArmResources, isArmLibraryNamespace, } from "@azure-tools/typespec-azure-resource-manager";
import { NoTarget, createProjectedNameProgram, getBaseFileName, getDirectoryPath, getDiscriminator, getDoc, getEncode, getFormat, getFriendlyName, getKnownValues, getMaxLength, getMinLength, getNamespaceFullName, getPattern, getTypeName, ignoreDiagnostics, interpolatePath, isNeverType, isTemplateDeclaration, joinPaths, listServices, resolvePath, } from "@typespec/compiler";
import { getQueryParamName, getRoutePath, isQueryParam, } from "@typespec/http";
import { getActionSegment, getParentResource } from "@typespec/rest";
import { getAddedOnVersions, getRemovedOnVersions, getVersionDependencies, resolveVersions, } from "@typespec/versioning";
import Handlebars from "handlebars";
import { fileURLToPath } from "url";
import { getTracer, reportDiagnostic } from "./lib.js";
export async function $onEmit(context) {
    const emitterOptions = context.options;
    const rootPath = resolvePath(getDirectoryPath(fileURLToPath(import.meta.url)), "..");
    const registrationOutputPath = emitterOptions["registration-output-path"] &&
        interpolatePath(emitterOptions["registration-output-path"], {
            "emitter-output-dir": context.emitterOutputDir,
        });
    let includeOperationController = false;
    if (emitterOptions["include-operation-controller"] !== undefined) {
        includeOperationController = emitterOptions["include-operation-controller"];
    }
    let includeCancellationToken = false;
    if (emitterOptions["include-cancellation-token"] !== undefined) {
        includeCancellationToken = emitterOptions["include-cancellation-token"];
    }
    let includeSubscriptionLifeCycleController = false;
    if (emitterOptions["include-subscription-lifecycle-controller"] !== undefined) {
        includeSubscriptionLifeCycleController =
            emitterOptions["include-subscription-lifecycle-controller"];
    }
    let includeVersioningClasses = false;
    if (emitterOptions["include-versioning-classes"] !== undefined) {
        includeVersioningClasses = emitterOptions["include-versioning-classes"];
    }
    const options = {
        controllerOutputPath: context.emitterOutputDir,
        controllerModulePath: rootPath,
        controllerHost: (emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions["controller-host"]) || "providerhub",
        operationPollingLocation: (emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions["operation-polling-location"]) || "tenant",
        registrationOutputPath,
        generatedCodeKind: (emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions["code-kind"]) || "full",
        includeOperationController: includeOperationController,
        includeCancellationToken: includeCancellationToken,
        includeSubscriptionLifeCycleController: includeSubscriptionLifeCycleController,
        includeVersioningClasses: includeVersioningClasses,
    };
    const generator = createServiceCodeGenerator(context.program, options);
    await (generator === null || generator === void 0 ? void 0 : generator.generateServiceCode(context.program.host));
}
function createServiceCodeGenerator(p, options) {
    const tracer = getTracer(p);
    const rootPath = options.controllerModulePath;
    const { program } = createProjectedNameProgram(p, "csharp");
    const jsonView = createProjectedNameProgram(p, "json");
    const services = listServices(p).filter((x) => getArmProviderNamespace(program, x.type));
    if (services.length === 0) {
        reportDiagnostic(p, {
            code: "no-provider-namespace",
            target: NoTarget,
        });
        return;
    }
    const service = services[0];
    const serviceRootNamespace = services[0].type;
    const serviceNamespaceName = getNamespaceFullName(serviceRootNamespace);
    if (!serviceNamespaceName || !serviceRootNamespace) {
        return {
            generateServiceCode() {
                return Promise.resolve();
            },
        };
    }
    checkNoServiceDependencies(serviceRootNamespace);
    const serviceName = getServiceName(serviceNamespaceName);
    const serviceNamespace = "Microsoft." + serviceName;
    const providerNamespace = getArmProviderNamespace(program, serviceRootNamespace);
    const serviceVersions = getServiceVersions(service);
    const PutName = "createOrUpdate", PatchName = "update", DeleteName = "delete", GetName = "read";
    const csharpTypeCache = new Map();
    tracer.trace("info", ["Generation info:", ` - Service name: ${serviceName}`, ` - Rootpath: ${rootPath}`].join("\n"));
    function getFullyQualifiedResourceType(resource) {
        const segments = [];
        let r = resource;
        while (r) {
            segments.push(r.resourceTypeName);
            r = r.parent;
        }
        segments.push(resource.nameSpace);
        return segments.reverse().join("/");
    }
    const outputModel = {
        nameSpace: serviceNamespace,
        providerNamespace: providerNamespace,
        serviceName: serviceName,
        resources: [],
        models: [],
        enumerations: [],
        versions: serviceVersions,
        includeOperationController: options.includeOperationController,
        includeCancellationToken: options.includeCancellationToken,
        includeSubscriptionLifeCycleController: options.includeSubscriptionLifeCycleController,
        includeVersioningClasses: options.includeVersioningClasses,
    };
    return { generateServiceCode };
    function getAnyDiscriminator(model) {
        const currentDiscriminator = getDiscriminator(program, model);
        if (currentDiscriminator) {
            return currentDiscriminator;
        }
        if (!currentDiscriminator && model.baseModel) {
            return getAnyDiscriminator(model.baseModel);
        }
        return undefined;
    }
    // for now, ensure that versioned dependencies are not in the service namespace
    function checkNoServiceDependencies(namespace) {
        function isVersionMap(checkType) {
            return checkType.delete !== undefined;
        }
        const deps = getVersionDependencies(program, namespace);
        if (deps && deps.size > 0) {
            for (const [_, value] of deps) {
                if (isVersionMap(value) && value.size > 1) {
                    const versions = new Set();
                    for (const [_, targetVersion] of value) {
                        versions.add(targetVersion);
                    }
                    if (
                    // Make sure every version is an approved dependency
                    !Array.from(versions).every((v) => {
                        const namespace = getTypeName(v.namespace);
                        return (namespace.startsWith("Azure.Core") || namespace.startsWith("Azure.ResourceManager"));
                    })) {
                        reportDiagnostic(program, {
                            code: "no-versioned-dependencies",
                            target: namespace,
                        });
                    }
                }
            }
        }
    }
    // get the versions defined on the root namespace
    function getServiceVersions(service) {
        var _a;
        const versions = [];
        const records = resolveVersions(program, service.type);
        if (records) {
            for (const version of records) {
                if (version.rootVersion !== undefined)
                    versions.push(version.rootVersion.value);
            }
        }
        if (versions.length < 1)
            versions.push((_a = service.version) !== null && _a !== void 0 ? _a : "0000-00-00");
        return versions;
    }
    function reportProgress(message) {
        tracer.trace("progress", message);
    }
    function getServiceName(serviceNamespace) {
        const dotPos = serviceNamespace.indexOf(".");
        return serviceNamespace.substring(dotPos + 1).replace(/\./g, "");
    }
    async function generateServiceCode(host) {
        var _a;
        const genPath = options.controllerOutputPath;
        const registrationOutputPath = options.registrationOutputPath;
        // maps resource model name to arm Namespace
        const resourceNamespaceTable = new Map();
        // create child model map
        const modelDiscriminatorInfoMap = new Map();
        function transformPathParameter(parameter, typespecType) {
            return {
                name: parameter.name,
                serializedName: jsonView.getProjectedName(parameter.param),
                type: "string",
                description: getDoc(program, parameter.param),
                sourceNode: typespecType.node,
            };
        }
        const modelsToGenerate = new Map();
        const resources = new Map();
        function populateResources() {
            var _a;
            const cancellationToken = {
                name: "cancellationToken",
                type: "CancellationToken",
                description: "The cancellation token.",
            };
            function getBodyParam(operation) {
                var _a;
                const bodyParam = (_a = operation.httpOperation.parameters.body) === null || _a === void 0 ? void 0 : _a.type;
                if (bodyParam === undefined || bodyParam.kind !== "Model") {
                    return undefined;
                }
                const outModel = getCSharpType(bodyParam);
                if (outModel === undefined)
                    return undefined;
                return {
                    name: "body",
                    type: outModel.name,
                    description: getDoc(program, bodyParam),
                    location: "body",
                    sourceNode: bodyParam.node,
                };
            }
            function getStandardOperation(operation, modelName, sourceType) {
                var _a;
                const pathParams = operation.httpOperation.parameters.parameters
                    .filter((p) => p.type === "path")
                    .map((p) => transformPathParameter(p, sourceType));
                const operationName = transformCSharpIdentifier(operation.name);
                const cancelParameter = options.includeCancellationToken
                    ? [cancellationToken]
                    : [];
                switch (operation.kind) {
                    case GetName:
                        return {
                            name: operationName,
                            kind: operation.kind,
                            parameters: [...pathParams, ...cancelParameter],
                            returnType: modelName,
                            verb: "GET",
                            sourceNode: sourceType.node,
                        };
                    case PutName:
                        return {
                            name: operationName,
                            kind: operation.kind,
                            parameters: [
                                ...pathParams,
                                {
                                    name: "body",
                                    location: "body",
                                    description: "The resource data.",
                                    type: modelName,
                                    sourceNode: sourceType.node,
                                },
                                ...cancelParameter,
                            ],
                            returnType: modelName,
                            verb: "PUT",
                            requestParameter: {
                                name: "body",
                                location: "body",
                                description: "The resource data.",
                                type: modelName,
                            },
                            sourceNode: sourceType.node,
                        };
                    case DeleteName:
                        return {
                            name: operationName,
                            kind: operation.kind,
                            parameters: [...pathParams, ...cancelParameter],
                            returnType: "void",
                            verb: "Delete",
                            sourceNode: sourceType.node,
                        };
                    case PatchName:
                        const bodyParam = (_a = getBodyParam(operation)) !== null && _a !== void 0 ? _a : {
                            name: "body",
                            location: "body",
                            description: "The resource patch data.",
                            type: `${modelName}Update`,
                            sourceNode: sourceType.node,
                        };
                        return {
                            name: operationName,
                            kind: operation.kind,
                            parameters: [...pathParams, bodyParam, ...cancelParameter],
                            returnType: modelName,
                            verb: "PATCH",
                            requestParameter: bodyParam,
                            sourceNode: sourceType.node,
                        };
                    default:
                        return undefined;
                }
            }
            const visitedTypes = new Set();
            const visitedOperations = new Map();
            function visitOperation(operation, httpOperation, resource) {
                var _a, _b, _c, _d, _e, _f;
                const operationType = operation.operation;
                const operationKey = httpOperation.container.name + "." + operationType.name;
                let bodyProp = undefined;
                if (!visitedOperations.has(operationKey)) {
                    visitedOperations.set(operationKey, operationType);
                    const returnType = extractResponseType(operationType);
                    if (returnType) {
                        visitType(returnType);
                    }
                    const parameters = [];
                    httpOperation.parameters.parameters.forEach((httpParam) => {
                        const prop = httpParam.param;
                        if (isQueryParam(program, prop) && getQueryParamName(program, prop) === "api-version") {
                            // skip standard api-version parameter
                            return;
                        }
                        const propType = getCSharpType(prop.type);
                        if (propType) {
                            visitType(prop.type);
                            const paramDescription = getDoc(program, prop);
                            ensureCSharpIdentifier(prop, prop.name);
                            parameters.push({
                                name: prop.name,
                                serializedName: jsonView.getProjectedName(prop),
                                type: propType.name,
                                description: paramDescription,
                                location: httpParam.type,
                                sourceNode: prop.node,
                                default: prop.default && formatDefaultValue(prop.type, prop.default),
                            });
                        }
                    });
                    if (httpOperation.parameters.body) {
                        const bodyParam = httpOperation.parameters.body.parameter;
                        const bodyType = getCSharpType(httpOperation.parameters.body.type);
                        const paramDescription = bodyParam ? getDoc(program, bodyParam) : undefined;
                        visitType(httpOperation.parameters.body.type);
                        if (bodyParam) {
                            ensureCSharpIdentifier(bodyParam, bodyParam.name);
                        }
                        if (bodyType) {
                            bodyProp = {
                                name: (_a = bodyParam === null || bodyParam === void 0 ? void 0 : bodyParam.name) !== null && _a !== void 0 ? _a : "body",
                                type: bodyType.name,
                                description: paramDescription,
                                location: "body",
                                sourceNode: bodyParam === null || bodyParam === void 0 ? void 0 : bodyParam.node,
                            };
                            parameters.push(bodyProp);
                        }
                    }
                    if (options.includeCancellationToken) {
                        parameters.push(cancellationToken);
                    }
                    ensureCSharpIdentifier(operationType, operationType.name);
                    const outOperation = {
                        name: transformCSharpIdentifier(operationType.name),
                        kind: operation.kind,
                        returnType: (_b = returnType === null || returnType === void 0 ? void 0 : returnType.name) !== null && _b !== void 0 ? _b : "void",
                        parameters: parameters,
                        subPath: (_c = getActionSegment(program, operation.operation)) !== null && _c !== void 0 ? _c : (_d = getRoutePath(program, operation.operation)) === null || _d === void 0 ? void 0 : _d.path,
                        verb: httpOperation.verb,
                        sourceNode: operationType.node,
                    };
                    if (bodyProp !== undefined) {
                        outOperation.requestParameter = bodyProp;
                    }
                    // use the default path for actions
                    if (outOperation.kind === "action" && !outOperation.subPath) {
                        outOperation.subPath = outOperation.name;
                    }
                    let exists = false;
                    if (resource) {
                        exists = (_f = (_e = resource.operations) === null || _e === void 0 ? void 0 : _e.some((op) => op.name === outOperation.name)) !== null && _f !== void 0 ? _f : false;
                    }
                    if (resource && !exists) {
                        resource.operations.push(outOperation);
                    }
                }
            }
            function visitModel(model) {
                var _a;
                function tryAddModel(model) {
                    const modelKey = getFriendlyName(program, model) || model.name;
                    if (!modelsToGenerate.has(modelKey) && !getKnownType(model)) {
                        modelsToGenerate.set(modelKey, model);
                    }
                }
                function addModelDiscriminatorInfoToMap(model, baseType, fieldName, discriminatorValue) {
                    const baseDiscriminatorInfo = {
                        baseType: baseType,
                        propertyName: fieldName,
                        value: discriminatorValue,
                    };
                    if (!modelDiscriminatorInfoMap.has(model)) {
                        modelDiscriminatorInfoMap.set(model, baseDiscriminatorInfo);
                    }
                }
                function visitProperty(prop, child) {
                    const decl = getPropertyDecl(prop, child);
                    if (decl) {
                        visitType(prop.type);
                    }
                    if (prop.default !== undefined) {
                        visitType(prop.default);
                    }
                }
                tryAddModel(model);
                // create discriminatorInfo if has @discriminator
                const discriminator = getDiscriminator(program, model);
                if (discriminator) {
                    const baseType = getCSharpType(model);
                    addModelDiscriminatorInfoToMap(model, baseType, discriminator.propertyName, "");
                    // add all children to be generated
                    for (const child of model.derivedModels.filter((x) => !isTemplateDeclaration(x))) {
                        const childFieldType = child.properties.get(discriminator.propertyName).type;
                        let defaultValue = "";
                        switch (childFieldType.kind) {
                            case "String":
                                defaultValue = (_a = childFieldType.value) === null || _a === void 0 ? void 0 : _a.toString();
                                break;
                            case "EnumMember":
                                defaultValue =
                                    childFieldType.value && typeof childFieldType.value === "string"
                                        ? childFieldType.value
                                        : childFieldType.name;
                        }
                        tryAddModel(child);
                        addModelDiscriminatorInfoToMap(child, baseType, discriminator.propertyName, defaultValue);
                        child.properties.forEach((prop) => {
                            visitProperty(prop, child);
                        });
                    }
                }
            }
            function extractResponseType(operation) {
                const model = operation.returnType;
                if (model.kind === "Union") {
                    let outModel = undefined;
                    let hasStandardEmptyResponse = false;
                    for (const variant of model.variants.values()) {
                        const option = variant.type;
                        if (option.kind === "Model" &&
                            (option.name === "ArmResponse" || option.name === "ArmResourceUpdatedResponse") &&
                            option.templateMapper) {
                            const innerModel = option.templateMapper.args[0];
                            if (innerModel && innerModel.kind === "Model") {
                                outModel = innerModel;
                            }
                        }
                        else if (option.kind === "Model") {
                            switch (option.name) {
                                case "ErrorResponse":
                                    break;
                                case "ArmNoContentResponse":
                                case "ArmAcceptedResponse":
                                case "ArmAcceptedLroResponse":
                                    hasStandardEmptyResponse = true;
                                    break;
                                default:
                                    outModel = option;
                                    break;
                            }
                        }
                    }
                    if (outModel === undefined && !hasStandardEmptyResponse) {
                        reportDiagnostic(program, {
                            code: "invalid-response",
                            format: { operationName: operation ? operation.name : "<unknown>" },
                            target: operation,
                        });
                    }
                    return outModel;
                }
                return model.kind === "Model" ? model : undefined;
            }
            function visitType(typespecType) {
                var _a, _b, _c;
                if (!visitedTypes.has(typespecType)) {
                    visitedTypes.add(typespecType);
                    switch (typespecType.kind) {
                        case "Tuple":
                            typespecType.values.forEach((element) => {
                                visitType(element);
                            });
                            break;
                        case "TemplateParameter":
                            (_a = typespecType.instantiationParameters) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
                                visitType(element);
                            });
                            break;
                        case "Union":
                            typespecType.variants.forEach((element) => {
                                visitType(element.type);
                            });
                            break;
                        case "ModelProperty":
                            visitType(typespecType.type);
                            break;
                        case "Model":
                            if (typespecType.baseModel) {
                                visitType(typespecType.baseModel);
                            }
                            (_c = (_b = typespecType.templateMapper) === null || _b === void 0 ? void 0 : _b.args) === null || _c === void 0 ? void 0 : _c.forEach((element) => {
                                visitType(element);
                            });
                            // A type with a friendly name should be treated as a unique type
                            if (getFriendlyName(program, typespecType) || !getKnownType(typespecType)) {
                                typespecType.properties.forEach((element) => {
                                    visitType(element);
                                });
                                visitModel(typespecType);
                            }
                            break;
                        default:
                            // do nothing
                            break;
                    }
                }
            }
            for (const resourceDetails of getArmResources(program)) {
                if (!resources.has(resourceDetails.name)) {
                    const modelName = resourceDetails.name;
                    const listName = `${modelName}ListResult`;
                    const matchingNamespace = resourceDetails.armProviderNamespace;
                    const cSharpModelName = transformCSharpIdentifier(modelName);
                    resourceNamespaceTable.set(modelName, resourceDetails.armProviderNamespace);
                    const standardOps = [
                        "read",
                        "createOrUpdate",
                        "update",
                        "delete",
                    ];
                    const map = new Map();
                    standardOps.forEach((op) => {
                        const armOperation = resourceDetails.operations.lifecycle[op];
                        if (armOperation) {
                            const value = getStandardOperation(armOperation, cSharpModelName, resourceDetails.typespecType);
                            if (value && !map.has(value.name)) {
                                map.set(value.name, value);
                            }
                        }
                    });
                    if (map.size < 1) {
                        if (!resourceDetails.typespecType.namespace ||
                            !isArmLibraryNamespace(program, resourceDetails.typespecType.namespace)) {
                            reportDiagnostic(program, {
                                code: "no-resource-operations",
                                format: { resource: resourceDetails.name },
                                target: resourceDetails.typespecType,
                            });
                        }
                        continue;
                    }
                    if (resourceDetails.operations.lifecycle.read === undefined &&
                        resourceDetails.operations.lifecycle.createOrUpdate === undefined) {
                        reportDiagnostic(program, {
                            code: "no-resource-read-or-create-operation",
                            format: { resource: resourceDetails.name },
                            target: resourceDetails.typespecType,
                        });
                        continue;
                    }
                    const parentResourceModel = getParentResource(program, resourceDetails.typespecType);
                    const parentResource = parentResourceModel
                        ? getArmResource(program, parentResourceModel)
                        : undefined;
                    const outResource = {
                        hasResourceGroupList: resourceDetails.operations.lists["ListByResourceGroup"] !== undefined,
                        hasSubscriptionList: resourceDetails.operations.lists["ListBySubscription"] !== undefined,
                        serviceName: serviceName,
                        // TODO: This is currently a problem!  We don't have a canonical path
                        itemPath: (resourceDetails.operations.lifecycle.read ||
                            resourceDetails.operations.lifecycle.createOrUpdate).path,
                        resourceTypePath: resourceDetails.resourceTypePath,
                        name: resourceDetails.name,
                        resourceTypeName: resourceDetails.collectionName,
                        parent: parentResource ? resources.get(parentResource.name) : undefined,
                        nameSpace: serviceNamespace,
                        nameParameter: (_a = resourceDetails.keyName) !== null && _a !== void 0 ? _a : "name",
                        serializedName: resourceDetails.collectionName,
                        operations: [...map.values()],
                        specificationArmProviderNamespace: matchingNamespace,
                        specificationModelName: transformCSharpIdentifier(modelName),
                        specificationListModelName: transformCSharpIdentifier(listName),
                        sourceNode: resourceDetails.typespecType.node,
                        includeCancellationToken: options.includeCancellationToken,
                        includeSubscriptionLifeCycleController: options.includeSubscriptionLifeCycleController,
                        includeVersioningClasses: options.includeVersioningClasses,
                    };
                    // Loop through the lifecycle operations again to visit their types
                    // now that we have the outResource
                    for (const lifecycleOp of Object.values(resourceDetails.operations.lifecycle)) {
                        visitOperation(lifecycleOp, lifecycleOp.httpOperation, outResource);
                    }
                    // Visit all action operations
                    for (const actionOpName in resourceDetails.operations.actions) {
                        const actionOp = resourceDetails.operations.actions[actionOpName];
                        visitOperation(actionOp, actionOp.httpOperation, outResource);
                    }
                    // NOTE: We explicitly skip visiting list operations because the
                    // MetaRP will be providing the behavior for listing all resource
                    // types.
                    resources.set(modelName, outResource);
                    outputModel.resources.push(outResource);
                }
            }
        }
        function populateModels() {
            const models = new Map();
            function populateModel(typespecType) {
                var _a, _b, _c, _d, _e, _f;
                if (typespecType.kind === "Model") {
                    const friendlyName = getFriendlyName(program, typespecType);
                    const typeRef = getCSharpType(typespecType);
                    tracer.trace("type-mapping", `*** ${typespecType.name} => ${typeRef === null || typeRef === void 0 ? void 0 : typeRef.name}`, typespecType.node);
                    if (typeRef) {
                        const outModel = {
                            name: (_a = friendlyName !== null && friendlyName !== void 0 ? friendlyName : typeRef === null || typeRef === void 0 ? void 0 : typeRef.name) !== null && _a !== void 0 ? _a : typespecType.name,
                            nameSpace: (_b = typeRef === null || typeRef === void 0 ? void 0 : typeRef.nameSpace) !== null && _b !== void 0 ? _b : serviceNamespace,
                            properties: [],
                            description: getDoc(program, typespecType),
                            serviceName: serviceName,
                            typeParameters: ((_c = typespecType.templateMapper) === null || _c === void 0 ? void 0 : _c.args)
                                ? typespecType.templateMapper.args.map((arg) => getCSharpType(arg))
                                : [],
                            isDerivedType: false,
                            isImplementer: false,
                            isBuiltIn: (_d = typeRef === null || typeRef === void 0 ? void 0 : typeRef.isBuiltIn) !== null && _d !== void 0 ? _d : false,
                            validations: getValidations(typespecType),
                            converters: getConverters(typespecType),
                            sourceNode: typespecType.node,
                            discriminatorInfo: modelDiscriminatorInfoMap.get(typespecType),
                            isVersioned: false,
                            isSerialized: false,
                            hasVersionedAncestor: false,
                        };
                        // The model type may need to derive from another type if:
                        // - It explicitly has a base model type
                        // - It is an instantiation of a templated type without a friendly name
                        //   (the friendly name is used to rename the type without derivation)
                        if (typespecType.baseModel ||
                            (!friendlyName &&
                                typespecType.templateMapper &&
                                typespecType.templateMapper.args &&
                                typespecType.templateMapper.args.length > 0)) {
                            outModel.isDerivedType = true;
                            const baseType = [];
                            if (typespecType.baseModel) {
                                const converted = getCSharpType(typespecType.baseModel);
                                if (converted) {
                                    baseType.push(converted);
                                }
                            }
                            if (typespecType.templateNode) {
                                const templateBase = program.checker.getTypeForNode(typespecType.templateNode);
                                if (templateBase && templateBase.kind === "Model") {
                                    const converted = getCSharpType(templateBase);
                                    if (converted) {
                                        baseType.push(converted);
                                    }
                                }
                            }
                            outModel.baseClass = baseType.length > 0 ? baseType[0] : undefined;
                        }
                        if (typespecType.properties && typespecType.properties.size > 0) {
                            // Filter out unwanted properties from the resource model type:
                            // - name: Use the name property defined in the base ArmResource type instead
                            // - systemData
                            (_f = (_e = [...typespecType.properties.values()]) === null || _e === void 0 ? void 0 : _e.filter((prop) => prop.name !== "systemData" &&
                                !(prop.name === "name" && getArmResource(program, typespecType)))) === null || _f === void 0 ? void 0 : _f.forEach((val) => {
                                const decl = getPropertyDecl(val, typespecType);
                                if (decl) {
                                    outModel.properties.push(decl);
                                    if (decl.versions.length > 0) {
                                        outModel.isVersioned = true;
                                    }
                                }
                            });
                        }
                        if (!outModel.isBuiltIn) {
                            models.set(outModel.name, outModel);
                        }
                    }
                }
            }
            function checkModelAncestors(model) {
                var _a, _b;
                const ancestors = new Map();
                function isVersioned(model) {
                    if (ancestors.has(model.name))
                        return false;
                    if (model.isVersioned || model.hasVersionedAncestor)
                        return true;
                    if (model.baseClass) {
                        const baseModel = models.get(model.baseClass.name);
                        if (baseModel) {
                            ancestors.set(baseModel.name, baseModel);
                            return isVersioned(baseModel);
                        }
                    }
                    return false;
                }
                let versioned = false;
                if (model.baseClass) {
                    const baseModel = models.get(model.baseClass.name);
                    if (baseModel) {
                        versioned = isVersioned(baseModel);
                    }
                }
                model.hasVersionedAncestor = versioned;
                if (model.isVersioned && !model.hasVersionedAncestor) {
                    model.isImplementer = true;
                    model.implements = (_a = model.implements) !== null && _a !== void 0 ? _a : [];
                    model.implements.push({
                        name: "IVersionedResource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub.Controller",
                        isBuiltIn: true,
                    });
                }
                if (!model.baseClass) {
                    model.isSerialized = true;
                    if (!model.isVersioned) {
                        model.isImplementer = true;
                        model.implements = (_b = model.implements) !== null && _b !== void 0 ? _b : [];
                        model.implements.push({
                            name: "ISerializationTracker",
                            nameSpace: "Microsoft.TypeSpec.ProviderHub.Controller",
                            isBuiltIn: true,
                        });
                    }
                }
            }
            modelsToGenerate.forEach((r) => {
                if (!models.has(r.name)) {
                    populateModel(r);
                }
            });
            models.forEach((model) => {
                checkModelAncestors(model);
                outputModel.models.push(model);
            });
            program.trace("providerhub-controller.generate", ["Models", "------", JSON.stringify(models, replacer)].join("\n"));
            program.trace("providerhub-controller.generate", ["Enums", "------", JSON.stringify(outputModel.enumerations, replacer)].join("\n"));
        }
        function replacer(key, value) {
            if (key === "sourceNode") {
                return "<redacted>";
            }
            if (value instanceof Map) {
                return {
                    dataType: "Map",
                    value: Array.from(value.entries()), // or with spread: value: [...value]
                };
            }
            else {
                return value;
            }
        }
        getArmResources(program).forEach((resource) => {
            const cType = getCSharpType(resource.typespecType);
            const resourceMeta = getArmResource(program, resource.typespecType);
            tracer.trace("resource", [
                "ARM RESOURCE DETAILS:",
                "--------------------",
                "  armProviderNamespace: " + resourceMeta.armProviderNamespace,
                "  resourceModelName: " + resourceMeta.name,
                "  resourceKind: " + resourceMeta.kind,
                "  collectionName: " + resourceMeta.collectionName,
                "  operations: " + resourceMeta.operations,
                "  resourceNameParam: " + resourceMeta.keyName,
                `-- ${resourceMeta.name} => ${cType === null || cType === void 0 ? void 0 : cType.nameSpace}.${cType === null || cType === void 0 ? void 0 : cType.name}`,
            ].join("\n"));
        });
        populateResources();
        populateModels();
        function getPropertyDecl(property, parent) {
            var _a;
            // check for potential template instantiations or other properties defined inline
            let isDiscriminatorProperty = false;
            switch (property.type.kind) {
                case "Model":
                    if (property.type.indexer === undefined &&
                        getFriendlyName(program, property.type) === undefined &&
                        ((property.type.templateNode && property.type.templateNode !== null) ||
                            (((_a = property.type.templateMapper) === null || _a === void 0 ? void 0 : _a.args) && property.type.templateMapper.args.length > 0))) {
                        reportDiagnostic(program, {
                            code: "no-inline-properties",
                            format: { propertyName: property.name, modelName: (parent === null || parent === void 0 ? void 0 : parent.name) || "" },
                            target: property,
                        });
                    }
                    break;
                case "Object":
                case "ModelProperty":
                case "Intrinsic":
                case "Number":
                case "String":
                case "Enum":
                case "EnumMember":
                case "Scalar":
                    break;
                default:
                    reportDiagnostic(program, {
                        code: "no-inline-properties",
                        format: { propertyName: property.name, modelName: (parent === null || parent === void 0 ? void 0 : parent.name) || "" },
                        target: property,
                    });
            }
            let outPropertyType = getCSharpType(property.type);
            if (parent) {
                let discriminator = getDiscriminator(program, parent);
                if (discriminator && property.name === discriminator.propertyName) {
                    return undefined;
                }
                discriminator = getAnyDiscriminator(parent);
                if (discriminator && property.name === discriminator.propertyName) {
                    outPropertyType = {
                        name: "string",
                        nameSpace: "System",
                        isBuiltIn: true,
                        isValueType: false,
                    };
                    isDiscriminatorProperty = true;
                }
            }
            if (outPropertyType.isValueType && property.optional) {
                outPropertyType = {
                    name: `${outPropertyType.name}?`,
                    nameSpace: outPropertyType.nameSpace,
                    isBuiltIn: outPropertyType.isBuiltIn,
                    isValueType: outPropertyType.isValueType,
                    typeParameters: outPropertyType.typeParameters
                        ? [...outPropertyType.typeParameters]
                        : undefined,
                };
            }
            ensureCSharpIdentifier(property, property.name);
            const outProperty = {
                name: transformCSharpIdentifier(property.name),
                serializedName: jsonView.getProjectedName(property.projectionSource),
                type: outPropertyType,
                validations: getValidations(property),
                converters: getConverters(property),
                versions: getVersions(property),
                description: getDoc(program, property),
                default: property.default &&
                    formatDefaultValue(property.type, property.default, isDiscriminatorProperty),
            };
            return outProperty;
        }
        function formatDefaultValue(propertyType, defaultValue, isDiscriminatorProperty = false) {
            switch (defaultValue.kind) {
                case "String":
                case "Number":
                case "Boolean":
                    return formatPrimitiveType(defaultValue);
                case "Tuple":
                    return formatTupleValue(propertyType, defaultValue);
                case "EnumMember":
                    return isDiscriminatorProperty
                        ? formatEnumDiscriminator(defaultValue)
                        : `${serviceNamespace}.Service.Models.${defaultValue.enum.name}.${defaultValue.name}`;
                default:
                    throw new Error(`Unsupported default value '${defaultValue.kind}'`);
            }
        }
        function formatEnumDiscriminator(value) {
            switch (typeof value.value) {
                case "string":
                    return `"${value.value}"`;
                case "number":
                    return `${value.value}`;
            }
            return "";
        }
        function formatTupleValue(propertyType, defaultValue) {
            const items = defaultValue.values.map((x) => { var _a; 
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            return formatDefaultValue((_a = propertyType.indexer) === null || _a === void 0 ? void 0 : _a.value, x); });
            const type = getCSharpType(propertyType);
            return `new ${type.name} { ${items.join(", ")} }`;
        }
        function formatPrimitiveType(type) {
            switch (type.kind) {
                case "String":
                    return `"${type.value}"`;
                case "Number":
                    return `${type.value}`;
                case "Boolean":
                    return `${type.value}`;
            }
        }
        function transformCSharpIdentifier(identifier) {
            return identifier[0].toLocaleUpperCase() + identifier.substring(1);
        }
        function isValidCSharpIdentifier(identifier) {
            return identifier.match(/^[A-Za-z_][\w-]*$/) !== null;
        }
        function ensureCSharpIdentifier(target, name) {
            var _a, _b;
            let location = "";
            switch (target.kind) {
                case "Enum":
                    location = `enum ${target.name}`;
                    break;
                case "EnumMember":
                    location = `enum ${target.enum.name}`;
                    break;
                case "Interface":
                    location = `interface ${target.name}`;
                    break;
                case "Model":
                    location = `model ${target.name}`;
                    break;
                case "ModelProperty": {
                    const model = target.model;
                    if (!model) {
                        reportDiagnostic(program, {
                            code: "missing-type-parent",
                            format: { type: "ModelProperty", name: target.name },
                            target: target,
                        });
                    }
                    else {
                        location = `property '${target.name}' in model ${model === null || model === void 0 ? void 0 : model.name}`;
                        if (!model.name) {
                            location = `parameter '${target.name}' in operation`;
                        }
                    }
                    break;
                }
                case "Namespace":
                    location = `namespace ${target.name}`;
                    break;
                case "Operation": {
                    const parent = target.interface
                        ? `interface ${target.interface.name}`
                        : `namespace ${(_a = target.namespace) === null || _a === void 0 ? void 0 : _a.name}`;
                    location = `operation ${target.name} in ${parent}`;
                    break;
                }
                case "Union":
                    location = `union ${target.name}`;
                    break;
                case "UnionVariant": {
                    if (target.node !== undefined) {
                        const parent = program.checker.getTypeForNode(target.node.parent);
                        if ((parent === null || parent === void 0 ? void 0 : parent.kind) === "Union")
                            location = `variant ${String(target.name)} in union ${parent === null || parent === void 0 ? void 0 : parent.name}`;
                    }
                    break;
                }
            }
            if (!isValidCSharpIdentifier(name)) {
                reportDiagnostic(program, {
                    code: "invalid-identifier",
                    format: { identifier: name, location: location },
                    target: (_b = target.node) !== null && _b !== void 0 ? _b : NoTarget,
                });
            }
        }
        function getPatternAttribute(parameter) {
            return {
                name: "Pattern",
                parameters: [
                    {
                        value: parameter,
                        type: "string",
                    },
                ],
            };
        }
        function getBase64UrlConverter() {
            return {
                name: "Base64UrlJsonConverter",
                parameters: [],
            };
        }
        function getLengthAttribute(minLength, maxLength) {
            var _a, _b;
            const output = {
                name: "Length",
                parameters: [],
            };
            if (minLength) {
                (_a = output.parameters) === null || _a === void 0 ? void 0 : _a.push({ type: "int", value: minLength });
            }
            if (maxLength) {
                (_b = output.parameters) === null || _b === void 0 ? void 0 : _b.push({ type: "int", value: maxLength });
            }
            return output;
        }
        function createInlineEnum(typespecType, name) {
            name !== null && name !== void 0 ? name : (name = typespecType.name);
            ensureCSharpIdentifier(typespecType, name);
            const outEnum = {
                isClosed: false,
                nameSpace: serviceNamespace,
                serviceName: serviceName,
                name: transformCSharpIdentifier(name),
                values: [],
                sourceNode: typespecType.node,
            };
            typespecType.members.forEach((option) => {
                ensureCSharpIdentifier(option, option.name);
                outEnum.values.push({
                    name: option.name,
                    value: option.value,
                    sourceNode: option.node,
                });
            });
            outputModel.enumerations.push(outEnum);
            const outType = {
                name: outEnum.name,
                nameSpace: "Microsoft.Service.Models",
                isBuiltIn: false,
                isValueType: true,
            };
            return outType;
        }
        function getValidations(typespecType) {
            var _a, _b;
            const visited = new Map();
            function getLocalValidators(localType) {
                if (visited.has(localType)) {
                    return visited.get(localType);
                }
                const output = [];
                // Add SafeInt attribute for safeint fields
                if (localType.kind === "Scalar" && localType.name === "safeint") {
                    output.push({
                        name: "SafeInt",
                    });
                }
                const pattern = getPattern(program, localType);
                if (pattern) {
                    output.push(getPatternAttribute(pattern));
                }
                const minLength = getMinLength(program, localType);
                const maxLength = getMaxLength(program, localType);
                if (minLength || maxLength) {
                    output.push(getLengthAttribute(minLength, maxLength));
                }
                visited.set(localType, output);
                return output;
            }
            const outValidations = getLocalValidators(typespecType);
            switch (typespecType.kind) {
                case "Tuple":
                    typespecType.values.forEach((v) => getValidations(v).forEach((val) => outValidations.push(val)));
                    break;
                case "Union":
                    typespecType.variants.forEach((variant) => getValidations(variant.type).forEach((val) => outValidations.push(val)));
                    break;
                case "Model":
                    if ((_a = typespecType.indexer) === null || _a === void 0 ? void 0 : _a.value) {
                        getValidations((_b = typespecType.indexer) === null || _b === void 0 ? void 0 : _b.value).forEach((i) => outValidations.push(i));
                    }
                    if (typespecType.baseModel) {
                        getValidations(typespecType.baseModel).forEach((val) => outValidations.push(val));
                    }
                    if (typespecType.templateNode) {
                        const templateType = program.checker.getTypeForNode(typespecType.templateNode);
                        getValidations(templateType).forEach((val) => outValidations.push(val));
                    }
                    break;
                case "Scalar":
                    if (typespecType.baseScalar) {
                        getValidations(typespecType.baseScalar).forEach((val) => outValidations.push(val));
                    }
                    break;
                case "ModelProperty":
                    getValidations(typespecType.type).forEach((val) => outValidations.push(val));
                    break;
                default:
                    // do nothing
                    break;
            }
            return outValidations;
        }
        function getConverters(typespecType) {
            var _a, _b;
            const visited = new Map();
            function getLocalConverters(localType) {
                var _a;
                if (visited.has(localType)) {
                    return visited.get(localType);
                }
                const output = [];
                const format = getFormat(program, localType);
                const encodeData = getEncode(program, localType);
                if ((encodeData && encodeData.encoding.toLowerCase() === "base64url") ||
                    (format && format === "base64Url")) {
                    output.push(getBase64UrlConverter());
                }
                // Add JsonConverter attribute for duration fields
                if (ignoreDiagnostics(program.checker.isTypeAssignableTo((_a = localType.projectionBase) !== null && _a !== void 0 ? _a : localType, program.checker.getStdType("duration"), localType))) {
                    output.push({
                        name: "XsdTimeSpanConverter",
                        parameters: [],
                    });
                }
                visited.set(localType, output);
                return output;
            }
            const outConverters = getLocalConverters(typespecType);
            switch (typespecType.kind) {
                case "Tuple":
                    typespecType.values.forEach((v) => getConverters(v).forEach((val) => outConverters.push(val)));
                    break;
                case "Union":
                    typespecType.variants.forEach((o) => getConverters(o.type).forEach((val) => outConverters.push(val)));
                    break;
                case "Model":
                    if ((_a = typespecType.indexer) === null || _a === void 0 ? void 0 : _a.value) {
                        getConverters((_b = typespecType.indexer) === null || _b === void 0 ? void 0 : _b.value).forEach((i) => outConverters.push(i));
                    }
                    if (typespecType.baseModel) {
                        getConverters(typespecType.baseModel).forEach((val) => outConverters.push(val));
                    }
                    if (typespecType.templateNode) {
                        const templateType = program.checker.getTypeForNode(typespecType.templateNode);
                        getConverters(templateType).forEach((val) => outConverters.push(val));
                    }
                    break;
                case "ModelProperty":
                    getConverters(typespecType.type).forEach((val) => outConverters.push(val));
                    break;
                default:
                    // do nothing
                    break;
            }
            return outConverters;
        }
        function getVersions(typespecType) {
            var _a, _b;
            const visited = new Map();
            function getLocalVersions(localType) {
                if (visited.has(localType)) {
                    return visited.get(localType);
                }
                const output = [];
                const added = getAddedOnVersions(program, localType);
                if (added && added.length > 0) {
                    // for now, add on a single attribute, verify that multiple attributes work as expected, then do this for each
                    output.push({ name: "Added", onVersion: added[0].value });
                }
                const removed = getRemovedOnVersions(program, localType);
                if (removed && removed.length > 0) {
                    // for now, add on a single attribute, verify that multiple attributes work as expected, then do this for each
                    output.push({ name: "Removed", onVersion: removed[0].value });
                }
                visited.set(localType, output);
                return output;
            }
            const outVersions = new Set(getLocalVersions(typespecType));
            if (outVersions.size === 0) {
                switch (typespecType.kind) {
                    case "ModelProperty":
                        getVersions(typespecType.type).forEach((i) => outVersions.add(i));
                        break;
                    case "Model":
                        if (typespecType.instantiationParameters) {
                            typespecType.instantiationParameters
                                .flatMap((i) => getVersions(i))
                                .forEach((i) => outVersions.add(i));
                        }
                        if ((_a = typespecType.indexer) === null || _a === void 0 ? void 0 : _a.value) {
                            getVersions((_b = typespecType.indexer) === null || _b === void 0 ? void 0 : _b.value).forEach((x) => outVersions.add(x));
                        }
                        break;
                    default:
                        // in the case of other types, versioning attributes on type components
                        // do not flow to model properties
                        break;
                }
            }
            return [...outVersions.values()];
        }
        function isSealedBaseModel(refType) {
            return refType && refType.isBuiltIn && refType.nameSpace.toLowerCase().startsWith("system");
        }
        function getCSharpType(typespecType) {
            const cached = csharpTypeCache.get(typespecType);
            if (cached) {
                return cached;
            }
            const type = getCSharpTypeInternal(typespecType);
            if (type) {
                csharpTypeCache.set(typespecType, type);
            }
            return type;
        }
        function getCSharpTypeInternal(typespecType) {
            switch (typespecType.kind) {
                case "String":
                    return { name: "string", nameSpace: "System", isBuiltIn: true, isValueType: false };
                case "Boolean":
                    return { name: "bool", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "Union":
                    // Need to figure out if we want to support unions, otherwise this will require a static analysis rule.
                    reportDiagnostic(program, { code: "no-union", target: typespecType.node });
                    return undefined;
                case "Tuple":
                    const params = [];
                    typespecType.values.forEach((val) => {
                        const ref = getCSharpType(val);
                        if (ref) {
                            params.push(ref);
                        }
                    });
                    return {
                        isBuiltIn: false,
                        name: "Tuple",
                        nameSpace: "System.Collections.Generic",
                        typeParameters: params,
                    };
                case "Enum":
                    return createInlineEnum(typespecType);
                case "EnumMember":
                    return {
                        isBuiltIn: false,
                        isValueType: true,
                        name: typespecType.enum.name,
                        nameSpace: serviceNamespace,
                    };
                case "Scalar":
                    const csharpType = getCSharpTypeForScalar(typespecType);
                    // Check if there is known value and then return an enum instead.
                    const values = getKnownValues(program, typespecType);
                    if (values) {
                        return createInlineEnum(values, typespecType.name);
                    }
                    else {
                        return csharpType;
                    }
                case "Model":
                    const friendlyName = getFriendlyName(program, typespecType);
                    // Is the type templated with only one type?
                    if (!friendlyName &&
                        typespecType.baseModel &&
                        (!typespecType.properties || typespecType.properties.size === 0)) {
                        const outRef = getCSharpType(typespecType.baseModel);
                        if (isSealedBaseModel(outRef)) {
                            return outRef;
                        }
                    }
                    const typespecIntrinsicType = getCSharpTypeForTypeSpecIntrinsicModels(typespecType);
                    if (typespecIntrinsicType !== undefined) {
                        return typespecIntrinsicType;
                    }
                    const known = getKnownType(typespecType);
                    if (typespecType.name === undefined || typespecType.name === "") {
                        return undefined;
                    }
                    if (known) {
                        return known;
                    }
                    const modelName = friendlyName !== null && friendlyName !== void 0 ? friendlyName : typespecType.name;
                    ensureCSharpIdentifier(typespecType, modelName);
                    return {
                        name: transformCSharpIdentifier(modelName),
                        nameSpace: serviceNamespace,
                        isBuiltIn: false,
                    };
                case "Intrinsic":
                    return undefined;
                case "TemplateParameter":
                    return undefined;
                default:
                    return undefined;
            }
        }
        function getCSharpTypeForTypeSpecIntrinsicModels(typespecType) {
            if (typespecType.indexer) {
                if (isNeverType(typespecType.indexer.key)) {
                }
                else {
                    const name = typespecType.indexer.key.name;
                    if (name === "string") {
                        const valType = typespecType.indexer.value;
                        return {
                            name: "IDictionary",
                            nameSpace: "System.Collections",
                            isBuiltIn: true,
                            typeParameters: [
                                { name: "string", nameSpace: "System", isBuiltIn: true },
                                getCSharpType(valType),
                            ],
                        };
                    }
                    else if (name === "integer") {
                        const arrType = getCSharpType(typespecType.indexer.value);
                        if (arrType) {
                            return {
                                name: arrType.name + "[]",
                                nameSpace: arrType.nameSpace,
                                isBuiltIn: true,
                            };
                        }
                        return undefined;
                    }
                }
            }
            return undefined;
        }
        function getCSharpTypeForScalar(scalar) {
            if (program.checker.isStdType(scalar)) {
                return getCSharpTypeForStdScalars(scalar);
            }
            else if (scalar.baseScalar) {
                return getCSharpTypeForScalar(scalar.baseScalar);
            }
            reportDiagnostic(program, {
                code: "unrecognized-scalar",
                format: { typeName: scalar.name },
                target: scalar,
            });
            return { name: "Object", nameSpace: "System", isBuiltIn: true, isValueType: false };
        }
        function getCSharpTypeForStdScalars(scalar) {
            switch (scalar.name) {
                case "bytes":
                    return { name: "byte[]", nameSpace: "System", isBuiltIn: true, isValueType: false };
                case "int8":
                    return { name: "SByte", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "uint8":
                    return { name: "Byte", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "int16":
                    return { name: "Int16", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "uint16":
                    return { name: "UInt16", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "int32":
                    return { name: "int", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "uint32":
                    return { name: "UInt32", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "integer":
                case "int64":
                    return { name: "long", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "uint64":
                    return { name: "UInt64", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "safeint":
                    return { name: "long", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "float":
                case "float64":
                    return { name: "double", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "float32":
                    return { name: "float", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "string":
                    return { name: "string", nameSpace: "System", isBuiltIn: true, isValueType: false };
                case "boolean":
                    return { name: "bool", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "plainDate":
                    return { name: "DateTime", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "utcDateTime":
                case "offsetDateTime":
                    return {
                        name: "DateTimeOffset",
                        nameSpace: "System",
                        isBuiltIn: true,
                        isValueType: true,
                    };
                case "plainTime":
                    return { name: "DateTime", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "duration":
                    return { name: "TimeSpan", nameSpace: "System", isBuiltIn: true, isValueType: true };
                case "numeric":
                    reportDiagnostic(program, { code: "no-numeric", target: scalar });
                    return { name: "Object", nameSpace: "System", isBuiltIn: true, isValueType: false };
                case "url":
                    return { name: "string", nameSpace: "System", isBuiltIn: true, isValueType: false };
                default:
                    reportDiagnostic(program, {
                        code: "unrecognized-scalar",
                        format: { typeName: scalar.name },
                        target: scalar,
                    });
                    return { name: "Object", nameSpace: "System", isBuiltIn: true, isValueType: false };
            }
        }
        function getKnownType(model) {
            var _a, _b;
            switch (model.name) {
                case "ErrorResponse":
                    return {
                        isBuiltIn: true,
                        name: "Resource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "ArmResponse":
                case "ArmResourceUpdatedResponse":
                    return {
                        isBuiltIn: true,
                        name: "ArmResponse",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "ArmNoContentResponse":
                case "ArmAcceptedResponse":
                case "ArmAcceptedLroResponse":
                case "ArmDeleteAcceptedResponse":
                case "ArmDeleteAcceptedLroResponse":
                case "ArmDeletedNoContentResponse":
                case "ArmCreatedResponse":
                case "ArmResourceCreatedResponse":
                case "ArmResourceCreatedSyncResponse":
                    return {
                        isBuiltIn: true,
                        name: "void",
                        nameSpace: "System",
                    };
                case "Operation":
                    return {
                        isBuiltIn: true,
                        name: "Operation",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "OperationListResult":
                    return {
                        isBuiltIn: true,
                        name: "OperationListResult",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "ArmResource":
                    return {
                        isBuiltIn: true,
                        name: "Resource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "TrackedResourceBase":
                case "TrackedResource": {
                    const baseResource = {
                        isBuiltIn: true,
                        name: "TrackedResource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                    if (model.templateMapper && model.templateMapper.args.length === 1) {
                        const propertiesType = getCSharpType(model.templateMapper.args[0]);
                        if (propertiesType) {
                            baseResource.typeParameters = [propertiesType];
                        }
                    }
                    return baseResource;
                }
                case "ProxyResourceBase":
                case "ProxyResource":
                    return {
                        isBuiltIn: true,
                        name: "ProxyResource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "SystemData":
                    return {
                        isBuiltIn: true,
                        name: "SystemData",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "ExtensionResourceBase":
                case "ExtensionResource":
                    return {
                        isBuiltIn: true,
                        name: "ProxyResource",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                    };
                case "Pageable":
                case "Page": {
                    const returnValue = {
                        isBuiltIn: true,
                        name: "Pageable",
                        nameSpace: "Microsoft.TypeSpec.ProviderHub",
                        typeParameters: [],
                    };
                    const innerType = ((_a = model.templateMapper) === null || _a === void 0 ? void 0 : _a.args)
                        ? getCSharpType((_b = model.templateMapper) === null || _b === void 0 ? void 0 : _b.args[0])
                        : undefined;
                    if (innerType) {
                        returnValue.typeParameters.push(innerType);
                    }
                    return returnValue;
                }
                default:
                    return undefined;
            }
        }
        async function generateResource(resource) {
            const resourceControllerPath = joinPaths(genPath, `${resource.name}Controller.cs`);
            const resourceControllerBasePath = joinPaths(genPath, `${resource.name}ControllerBase.cs`);
            const resourceControllerBaseBasePath = joinPaths(genPath, "ResourceControllerBase.cs");
            const resourceControllerBaseLoggerPath = joinPaths(genPath, `${resource.name}ControllerBase.Logger.cs`);
            tracer.trace("info", "Writing resource controller for " + resource.name, undefined);
            await program.host.writeFile(resolvePath(resourceControllerBasePath), await compileHandlebarsTemplate(resolvePath(joinPaths(templatePath, "resourceControllerBase.sq")), resource));
            await program.host.writeFile(resolvePath(resourceControllerBaseBasePath), await compileHandlebarsTemplate(resolvePath(joinPaths(templatePath, "resourceControllerBase.Common.sq")), resource));
            await program.host.writeFile(resolvePath(resourceControllerBaseLoggerPath), await compileHandlebarsTemplate(resolvePath(joinPaths(templatePath, "resourceControllerBase.Logger.sq")), resource));
            await program.host.writeFile(resolvePath(resourceControllerPath), await compileHandlebarsTemplate(resolvePath(joinPaths(templatePath, "resourceController.sq")), resource));
            if (registrationOutputPath) {
                await generateRegistration(resource);
            }
        }
        async function generateResourceProviderReg(serviceModel) {
            const outputPath = joinPaths(registrationOutputPath, `${serviceModel.providerNamespace}.json`);
            const regTemplate = resolvePath(joinPaths(templatePath, "resourceProviderRegistration.sq"));
            await program.host.writeFile(outputPath, await compileHandlebarsTemplate(regTemplate, { serviceName: serviceModel.serviceName }));
        }
        async function generateRegistration(resource) {
            var _a;
            const fullyQualifiedResourceType = getFullyQualifiedResourceType(resource);
            const resourceRegistrationPath = joinPaths(registrationOutputPath, `${fullyQualifiedResourceType}.json`);
            await createDirIfNotExists(getDirectoryPath(resourceRegistrationPath)).catch((err) => reportDiagnostic(program, {
                code: "creating-dir",
                format: { error: err },
                target: NoTarget,
            }));
            tracer.trace("info", `Writing resource registrations for ${fullyQualifiedResourceType}`, undefined);
            const extensions = new Set();
            for (const operation of (_a = resource.operations) !== null && _a !== void 0 ? _a : []) {
                const extensionMap = {
                    put: ["ResourceCreationValidate", "ResourceCreationBegin", "ResourceCreationCompleted"],
                    patch: ["ResourcePatchValidate", "ResourcePatchBegin", "ResourcePatchCompleted"],
                    delete: [
                        "ResourceDeletionValidate",
                        "ResourceDeletionBegin",
                        "ResourceDeletionCompleted",
                    ],
                    get: ["ResourceReadValidate"],
                    post: ["ResourcePostAction"],
                };
                const _extensions = extensionMap[operation.verb.toLowerCase()];
                if (_extensions) {
                    _extensions.forEach((element) => {
                        extensions.add(element);
                    });
                }
            }
            await program.host.writeFile(resolvePath(resourceRegistrationPath), await compileHandlebarsTemplate(resolvePath(joinPaths(templatePath, "resourceRegistration.sq")), {
                apiVersion: serviceVersions,
                extensions: Array.from(extensions.values()),
            }));
        }
        async function generateModel(model) {
            async function renderModelTemplate(outFile, templateFile, model) {
                await program.host.writeFile(resolvePath(outFile), await compileHandlebarsTemplate(templateFile, model));
            }
            await renderModelTemplate(joinPaths(genPath, "models", model.name + ".cs"), resolvePath(joinPaths(templatePath, "model.sq")), model);
            if (!model.baseClass || model.baseClass.name !== "Pageable") {
                await renderModelTemplate(joinPaths(genPath, "models", `${model.name}CopyHelper.cs`), resolvePath(joinPaths(templatePath, "modelCopy.sq")), model);
                await renderModelTemplate(joinPaths(genPath, "models", `${model.name}Extensions.cs`), resolvePath(joinPaths(templatePath, "modelCopyExtension.sq")), model);
            }
            if (model.isVersioned) {
                const template = model.hasVersionedAncestor
                    ? "modelVersionComposite.sq"
                    : "modelVersionStandard.sq";
                await renderModelTemplate(joinPaths(genPath, "models", `${model.name}VersionInfo.cs`), resolvePath(joinPaths(templatePath, template)), model);
            }
        }
        async function generateEnum(model) {
            const modelPath = genPath + "/models/" + model.name + ".cs";
            const templateFile = resolvePath(joinPaths(templatePath, model.isClosed ? "closedEnum.sq" : "openEnum.sq"));
            await program.host.writeFile(resolvePath(modelPath), await compileHandlebarsTemplate(templateFile, model));
        }
        async function generateSingleDirectory(basePath, outPath) {
            reportProgress("+++++++");
            reportProgress("Generating single file templates");
            reportProgress("  basePath: " + basePath);
            reportProgress("  outPath: " + outPath);
            const singleTemplatePath = joinPaths(templatePath, "single");
            const files = await host.readDir(singleTemplatePath);
            for (const file of files) {
                // If we are not asked to include the operation controller, skip any
                // singleton files starting with "Operation"
                if (!options.includeOperationController) {
                    if (file.startsWith("Operation")) {
                        continue;
                    }
                }
                const templatePath = resolvePath(joinPaths(singleTemplatePath, file));
                await generateSingleFile(templatePath, outPath).catch((err) => reportDiagnostic(program, {
                    code: "creating-file",
                    format: { filename: file, error: err },
                    target: NoTarget,
                }));
            }
            reportProgress("++++++");
            async function generateSingleFile(templatePath, outPath) {
                const templateFile = getBaseFileName(templatePath);
                const baseName = templateFile.substring(0, templateFile.lastIndexOf("."));
                const outFile = joinPaths(outPath, baseName + ".cs");
                reportProgress(`    -- ${templateFile} => ${outFile}`);
                const content = await compileHandlebarsTemplate(templatePath, outputModel);
                await program.host.writeFile(resolvePath(outFile), content).catch((err) => reportDiagnostic(program, {
                    code: "writing-file",
                    format: { filename: outFile, error: err },
                    target: NoTarget,
                }));
            }
        }
        async function createDirIfNotExists(targetPath) {
            if (!(await program.host.stat(targetPath).catch((err) => {
                return false;
            }))) {
                await program.host.mkdirp(targetPath);
            }
        }
        async function ensureCleanDirectory(targetPath) {
            try {
                await program.host.stat(targetPath);
                await host.rm(targetPath, { recursive: true });
            }
            catch { }
            await host.mkdirp(targetPath);
        }
        const service = outputModel.serviceName;
        const templates = new Map();
        Handlebars.registerPartial("renderComment", '{{#each (split description "\n") as |line|}}/// {{trim line}}\n{{/each}}');
        const compileHandlebarsTemplate = async (fileName, data) => {
            let templateDelegate = templates.get(fileName);
            if (!templateDelegate) {
                const generationViewTemplate = (await program.host.readFile(fileName)).text;
                templateDelegate = Handlebars.compile(generationViewTemplate, {
                    noEscape: true,
                });
                templates.set(fileName, templateDelegate);
            }
            return templateDelegate(data, { helpers: commonHelper });
        };
        const commonHelper = {
            decl: (op) => op.parameters
                .map((p) => p.type + " " + p.name + (p.default ? ` = ${p.default}` : ""))
                .join(", "),
            call: (op) => op.parameters.map((p) => p.name).join(", "),
            increment: (i) => i + 1,
            decrement: (i) => i - 1,
            bodyParamName: (op) => op.parameters[op.parameters.length - 1].name,
            typeParamList: (op) => op.typeParameters.map((p) => p.name).join(", "),
            callByValue: (op) => op.parameters
                .map((p) => (p.type === "string" ? `@"${p.value}"` : p.value))
                .join(", "),
            initialCaps: (str) => str ? str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() : "",
            isDefined: (value) => value !== undefined,
            eq: (a, b) => a === b,
            eqi: (a, b) => a.toLowerCase() === b.toLowerCase(),
            ne: (a, b) => a !== b,
            or: (a, b) => !!a || !!b,
            and: (a, b) => a && b,
            not: (a) => !a,
            contains: (a, b) => a.includes(b),
            notCustomOp: (op) => op.kind !== "action",
            getOperationAction: (operation) => {
                const subPath = operation.subPath || "";
                const actionName = subPath.length ? subPath[0].toUpperCase() + subPath.substring(1) : "";
                const mapping = {
                    get: "Read",
                    put: "Create",
                    delete: "Delete",
                    patch: "Patch",
                    post: actionName,
                };
                return operation.kind === "action" ? actionName : mapping[operation.verb.toLowerCase()];
            },
            join: (arr, separator) => arr.join(separator),
            joinByName: (arr, separator) => arr.map((i) => i.name).join(separator),
            split: (str, separator) => (str ? str.split(separator) : ""),
            trim: (str) => (str ? str.trim() : ""),
            // cspell:ignore csharpname
            csharpname: (str) => transformCSharpIdentifier(str),
            curly: (open) => (open ? "{" : "}"),
            hasConverter: (model) => { var _a; return ((_a = model === null || model === void 0 ? void 0 : model.properties) === null || _a === void 0 ? void 0 : _a.some((p) => p.converters.length)) || (model === null || model === void 0 ? void 0 : model.discriminatorInfo); },
            versionName: (v) => `Version_${v.replace(/-/g, "").replace("preview", "Preview")}`,
        };
        const operationsPath = genPath;
        const routesPath = resolvePath(joinPaths(genPath, service + "ServiceRoutes.cs"));
        const serializerPath = resolvePath(joinPaths(genPath, "VersionedSerializer.cs"));
        const contractResolverPath = resolvePath(joinPaths(genPath, "VersionedContractResolver.cs"));
        const versionCollectionPath = resolvePath(joinPaths(genPath, `${service}ServiceVersions.cs`));
        const templatePath = resolvePath(joinPaths(rootPath, "..", "templates", options.controllerHost));
        const modelsPath = joinPaths(genPath, "models");
        if (!program.compilerOptions.noEmit && !program.hasError()) {
            await ensureCleanDirectory(genPath).catch((err) => reportDiagnostic(program, {
                code: "cleaning-dir",
                format: { error: err },
                target: NoTarget,
            }));
            await createDirIfNotExists(operationsPath).catch((err) => reportDiagnostic(program, {
                code: "creating-dir",
                format: { error: err },
                target: NoTarget,
            }));
            if (options.generatedCodeKind !== "controller") {
                await createDirIfNotExists(modelsPath).catch((err) => reportDiagnostic(program, {
                    code: "creating-dir",
                    format: { error: err },
                    target: NoTarget,
                }));
            }
            if (options.generatedCodeKind !== "controller" && outputModel.versions) {
                if ((options.includeVersioningClasses && outputModel.versions.length > 0) ||
                    outputModel.versions.length > 1) {
                    await program.host.writeFile(versionCollectionPath, await compileHandlebarsTemplate(joinPaths(templatePath, "versionCollection.sq"), outputModel));
                    await program.host.writeFile(contractResolverPath, await compileHandlebarsTemplate(joinPaths(templatePath, "versionedContractResolver.sq"), outputModel));
                    await program.host.writeFile(serializerPath, await compileHandlebarsTemplate(joinPaths(templatePath, "versionedSerializer.sq"), outputModel));
                }
            }
            await generateSingleDirectory(rootPath, operationsPath).catch((err) => reportDiagnostic(program, {
                code: "creating-dir",
                format: { error: err },
                target: NoTarget,
            }));
            if (registrationOutputPath) {
                if (resolvePath(registrationOutputPath) !== resolvePath(genPath)) {
                    await ensureCleanDirectory(registrationOutputPath).catch((err) => reportDiagnostic(program, {
                        code: "cleaning-dir",
                        format: { error: err },
                        target: NoTarget,
                    }));
                    await createDirIfNotExists(joinPaths(registrationOutputPath, outputModel.providerNamespace)).catch((err) => reportDiagnostic(program, {
                        code: "creating-dir",
                        format: { error: err },
                        target: NoTarget,
                    }));
                }
                await generateResourceProviderReg(outputModel);
            }
            if (options.generatedCodeKind !== "model") {
                await program.host.writeFile(routesPath, await compileHandlebarsTemplate(joinPaths(templatePath, "serviceRoutingConstants.sq"), outputModel));
                for (const resource of outputModel.resources) {
                    await generateResource(resource).catch((error) => {
                        var _a, _b;
                        return reportDiagnostic(program, {
                            code: "generating-resource",
                            format: {
                                namespace: (_a = resource === null || resource === void 0 ? void 0 : resource.nameSpace) !== null && _a !== void 0 ? _a : "",
                                resourceName: (_b = resource === null || resource === void 0 ? void 0 : resource.name) !== null && _b !== void 0 ? _b : "",
                                error,
                            },
                            target: NoTarget,
                        });
                    });
                }
            }
            if (options.generatedCodeKind !== "controller") {
                outputModel.models = outputModel.models.filter((m) => !outputModel.enumerations.some((e) => e.name === m.name));
                for (const model of outputModel.models) {
                    tracer.trace("info", `Rendering model ${model.nameSpace}.${model.name}`, model.sourceNode);
                    await generateModel(model).catch((error) => {
                        var _a, _b;
                        return reportDiagnostic(program, {
                            code: "generating-model",
                            format: {
                                namespace: (_a = model === null || model === void 0 ? void 0 : model.nameSpace) !== null && _a !== void 0 ? _a : "",
                                modelName: (_b = model === null || model === void 0 ? void 0 : model.name) !== null && _b !== void 0 ? _b : "",
                                error,
                            },
                            target: NoTarget,
                        });
                    });
                }
                for (const enumeration of (_a = outputModel.enumerations) !== null && _a !== void 0 ? _a : []) {
                    tracer.trace("info", `Rendering enum ${enumeration.name}`, enumeration.sourceNode);
                    await generateEnum(enumeration);
                }
            }
        }
    }
}
//# sourceMappingURL=generate.js.map