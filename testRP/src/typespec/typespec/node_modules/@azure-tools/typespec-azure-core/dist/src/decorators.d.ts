import { DecoratorContext, Diagnostic, Enum, EnumMember, IntrinsicType, Model, ModelProperty, Operation, Program, Scalar, StringLiteral, Type } from "@typespec/compiler";
import { OperationLink } from "./lro-helpers.js";
import { PropertyMap, ResultInfo, StatusMonitorMetadata } from "./lro-info.js";
export declare const PollingOperationKey: string;
export declare const FinalOperationKey = "final";
export declare function $fixed(context: DecoratorContext, target: Enum): void;
export declare function isFixed(program: Program, target: Enum): boolean;
export declare function $pagedResult(context: DecoratorContext, entity: Model): void;
export interface PagedResultMetadata {
    modelType: Model;
    itemsProperty?: ModelProperty;
    /** @deprecated use itemsSegments  */
    itemsPath?: string;
    /** Path to the items property. */
    itemsSegments?: string[];
    nextLinkProperty?: ModelProperty;
    /** @deprecated use nextLinkSegments */
    nextLinkPath?: string;
    /** Path to the next link property. */
    nextLinkSegments?: string[];
    nextLinkOperation?: Operation;
}
/**
 * Retrieves PagedResultMetadata for a model, if available. If passed an
 * operation, this will search the operations return type for any paged
 * response and return the PagedResultMetadata for that response.
 */
export declare function getPagedResult(program: Program, entity: Model | Operation): PagedResultMetadata | undefined;
export declare function $items(context: DecoratorContext, entity: ModelProperty): void;
/**
 * Returns `true` if the property is marked with `@items`.
 */
export declare function getItems(program: Program, entity: Type): boolean | undefined;
export declare function $nextLink(context: DecoratorContext, entity: ModelProperty): void;
/**
 * Returns `true` if the property is marked with `@nextLink`.
 */
export declare function getNextLink(program: Program, entity: Type): boolean | undefined;
/**
 *  Provides the names of terminal long-running operation states plus any
 *  additional states defined for the operation.
 **/
export interface LongRunningStates {
    succeededState: string[];
    failedState: string[];
    canceledState: string[];
    states: string[];
}
export declare function $lroStatus(context: DecoratorContext, entity: Enum | ModelProperty): void;
export declare function extractLroStates(program: Program, entity: Type): [LongRunningStates | undefined, readonly Diagnostic[]];
/**
 *  Returns the `LongRunningStates` associated with `entity`.
 */
export declare function getLongRunningStates(program: Program, entity: Enum | Model | Scalar | ModelProperty): LongRunningStates | undefined;
/**
 * Return the property that contains the lro status
 * @param program The program to process
 * @param target The model to check for lro status
 */
export declare function getLroStatusProperty(program: Program, target: Model): ModelProperty | undefined;
/**
 * Marks the property in a StatusMonitor that contains the logical result
 * of a successful operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the logical result.
 */
export declare function $lroResult(context: DecoratorContext, entity: ModelProperty): void;
/**
 * Gets the logical result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default result property if no other
 * property is marked. (defaults to true)
 */
export declare function getLroResult(program: Program, entity: Model, useDefault?: boolean): [ModelProperty | undefined, readonly Diagnostic[]];
/**
 * Marks the property in a StatusMonitor that contains the error result
 * of a failed operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the error result.
 */
export declare function $lroErrorResult(context: DecoratorContext, entity: ModelProperty): void;
/**
 * Gets the error result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default error property if no other
 * property is marked. (defaults to true)
 */
export declare function getLroErrorResult(program: Program, entity: Model, useDefault?: boolean): [ModelProperty | undefined, readonly Diagnostic[]];
export declare function $pollingOperationParameter(context: DecoratorContext, entity: ModelProperty, target?: ModelProperty | StringLiteral): void;
export declare function getPollingOperationParameter(program: Program, entity: ModelProperty): string | ModelProperty | undefined;
export declare function $lroSucceeded(context: DecoratorContext, entity: EnumMember): void;
/**
 *  Returns `true` if the enum member represents a "succeeded" state.
 */
export declare function isLroSucceededState(program: Program, entity: EnumMember): boolean;
export declare function $lroCanceled(context: DecoratorContext, entity: EnumMember): void;
/**
 *  Returns `true` if the enum member represents a "canceled" state.
 */
export declare function isLroCanceledState(program: Program, entity: EnumMember): boolean;
export declare function $lroFailed(context: DecoratorContext, entity: EnumMember): void;
/**
 *  Returns `true` if the enum member represents a "failed" state.
 */
export declare function isLroFailedState(program: Program, entity: EnumMember): boolean;
/** Extra information about polling control stored with a polling link */
export type PollingLocationInfo = StatusMonitorPollingLocationInfo;
/** The abstract type for polling control information */
export interface PollingLocationBase {
    /** The kind of polling being done */
    kind: pollingOptionsKind;
    /** The model property containing the polling link */
    target: ModelProperty;
    /** The type of the poller */
    pollingModel?: Model | IntrinsicType;
    /** The type of the final result after polling completes */
    finalResult?: Model | IntrinsicType;
}
/** Collected data for status monitor polling links */
export interface StatusMonitorPollingLocationInfo extends PollingLocationBase {
    /** The kind of status monitor */
    kind: pollingOptionsKind.StatusMonitor;
    /** The status monitor detailed data for control of polling. */
    info: StatusMonitorMetadata;
}
export declare enum pollingOptionsKind {
    StatusMonitor = "statusMonitor"
}
export declare function $pollingLocation(context: DecoratorContext, entity: ModelProperty, options?: Model): void;
/**
 * Gets polling information stored with a field that contains a link to an Lro polling endpoint
 * @param program The program to check
 * @param target The ModelProperty to check for polling info
 */
export declare function getPollingLocationInfo(program: Program, target: ModelProperty): PollingLocationInfo | undefined;
/**
 *  Returns `true` if the property is marked with @pollingLocation.
 */
export declare function isPollingLocation(program: Program, entity: ModelProperty): boolean;
export declare function $finalLocation(context: DecoratorContext, entity: ModelProperty, finalResult?: Model | IntrinsicType): void;
/**
 *  Returns `true` if the property is marked with @finalLocation.
 */
export declare function isFinalLocation(program: Program, entity: ModelProperty): boolean;
export declare function getFinalLocationValue(program: Program, entity: ModelProperty): Model | IntrinsicType | undefined;
export declare function $omitKeyProperties(context: DecoratorContext, entity: Model): void;
export interface OperationLinkMetadata {
    parameters?: Type;
    linkedOperation: Operation;
    linkType: string;
    link?: OperationLink;
    parameterMap?: Map<string, PropertyMap>;
    result?: ResultInfo;
}
export declare function $operationLink(context: DecoratorContext, entity: Operation, linkedOperation: Operation, linkType: string, parameters?: Model): void;
/**
 * Returns the `OperationLinkMetadata` for a given operation and link type, or undefined.
 */
export declare function getOperationLink(program: Program, entity: Operation, linkType: string): OperationLinkMetadata | undefined;
/**
 * Returns the collection of `OperationLinkMetadata` for a given operation, if any, or undefined.
 */
export declare function getOperationLinks(program: Program, entity: Operation): Map<string, OperationLinkMetadata> | undefined;
export declare function $pollingOperation(context: DecoratorContext, target: Operation, linkedOperation: Operation, parameters?: Model): void;
export declare function $finalOperation(context: DecoratorContext, entity: Operation, linkedOperation: Operation, parameters?: Model): void;
export declare function $nextPageOperation(context: DecoratorContext, entity: Operation, linkedOperation: Operation, parameters?: Model): void;
export declare function $requestParameter(context: DecoratorContext, entity: Model, name: string): void;
export declare function getRequestParameter(program: Program, entity: ModelProperty): string | undefined;
export declare function $responseProperty(context: DecoratorContext, entity: Model, name: string): void;
export declare function getResponseProperty(program: Program, entity: ModelProperty): string | undefined;
export declare function $spreadCustomParameters(context: DecoratorContext, entity: Model, customizations: Model): void;
export declare function $spreadCustomResponseProperties(context: DecoratorContext, entity: Model, customizations: Model): void;
export declare function $ensureResourceType(context: DecoratorContext, entity: Operation, resourceType: Type): void;
export declare function isResourceOperation(program: Program, operation: Operation): boolean;
export declare function $needsRoute(context: DecoratorContext, entity: Operation): void;
export declare function checkRpcRoutes(program: Program): void;
export declare function $ensureVerb(context: DecoratorContext, entity: Operation, templateName: string, verb: string): void;
export declare function checkEnsureVerb(program: Program): void;
export interface EmbeddingVectorMetadata {
    elementType: Type;
}
/**
 * If the provided model is an embedding vector, returns the appropriate metadata; otherwise,
 * returns undefined.
 * @param model the model to query
 * @returns `EmbeddingVectorMetadata`, if applicable, or undefined.
 */
export declare function getAsEmbeddingVector(program: Program, model: Model): EmbeddingVectorMetadata | undefined;
//# sourceMappingURL=decorators.d.ts.map