import { createDiagnosticCollector, getEffectiveModelType, isErrorType, } from "@typespec/compiler";
import { getHeaderFieldName, getOperationParameters, getResponsesForOperation, isHeader, isMetadata, } from "@typespec/http";
import { extractLroStates, getLongRunningStates, getLroErrorResult, getLroResult, getLroStatusProperty, getPollingOperationParameter, isPollingLocation, } from "./decorators.js";
import { createDiagnostic } from "./lib.js";
import { getAllProperties } from "./utils.js";
export function extractStatusMonitorInfo(program, model, statusProperty) {
    var _a, _b, _c, _d;
    const diagnosticsToToss = createDiagnosticCollector();
    const diagnosticsToKeep = createDiagnosticCollector();
    const lroResult = diagnosticsToKeep.pipe(getLroResult(program, model, true));
    const successProperty = (lroResult === null || lroResult === void 0 ? void 0 : lroResult.kind) === "ModelProperty" ? lroResult : undefined;
    const errorProperty = diagnosticsToKeep.pipe(getLroErrorResult(program, model, true));
    const states = (_a = getLongRunningStates(program, statusProperty)) !== null && _a !== void 0 ? _a : diagnosticsToToss.pipe(extractLroStates(program, statusProperty));
    if (!states || !statusProperty)
        return diagnosticsToKeep.wrap(undefined);
    return diagnosticsToKeep.wrap({
        monitorType: (_b = getEffectiveModelType(program, model, (p) => !isMetadata(program, p))) !== null && _b !== void 0 ? _b : model,
        successProperty: successProperty,
        errorProperty: errorProperty,
        statusProperty: statusProperty,
        lroStates: states,
        errorType: (errorProperty === null || errorProperty === void 0 ? void 0 : errorProperty.type.kind) === "Model" ? errorProperty.type : undefined,
        successType: ((_c = successProperty === null || successProperty === void 0 ? void 0 : successProperty.type) === null || _c === void 0 ? void 0 : _c.kind) === "Intrinsic" || ((_d = successProperty === null || successProperty === void 0 ? void 0 : successProperty.type) === null || _d === void 0 ? void 0 : _d.kind) === "Model"
            ? successProperty.type
            : program.checker.voidType,
        terminationInfo: {
            kind: "model-property",
            property: statusProperty,
            canceledState: states.canceledState,
            failedState: states.failedState,
            succeededState: states.succeededState,
        },
    });
}
export function getLroOperationInfo(program, sourceOperation, targetOperation, parameters) {
    const diagnostics = createDiagnosticCollector();
    const targetResponses = diagnostics.pipe(getResponsesForOperation(program, targetOperation));
    const targetParameters = diagnostics.pipe(getOperationParameters(program, targetOperation));
    const targetProperties = new Map();
    const parameterMap = new Map();
    const unmatchedParameters = new Set(targetParameters.parameters.flatMap((p) => p.name));
    for (const parameter of targetParameters.parameters) {
        targetProperties.set(parameter.name, parameter.param);
    }
    if (targetParameters.body) {
        const body = targetParameters.body;
        if (body.parameter) {
            targetProperties.set(body.parameter.name, body.parameter);
        }
        else if (body.type.kind === "Model") {
            for (const [name, param] of getAllProperties(body.type)) {
                targetProperties.set(name, param);
            }
        }
    }
    const sourceResponses = diagnostics.pipe(getResponsesForOperation(program, sourceOperation));
    const sourceParameters = diagnostics.pipe(getOperationParameters(program, sourceOperation));
    const sourceBodyProperties = new Map();
    if (sourceParameters.body && sourceParameters.body.type.kind === "Model") {
        for (const [sourceName, sourceProp] of getAllProperties(sourceParameters.body.type)) {
            sourceBodyProperties.set(sourceName, sourceProp);
            handleExplicitParameterMap(sourceProp, "RequestBody");
        }
    }
    const sourceParamProperties = new Map();
    for (const parameter of sourceParameters.parameters) {
        sourceParamProperties.set(parameter.name, parameter.param);
        handleExplicitParameterMap(parameter.param, "RequestParameter");
    }
    const sourceResponseProperties = new Map();
    let pollingLink = undefined;
    let resultModel;
    for (const response of targetResponses) {
        visitResponse(program, response, (model) => {
            if (!isErrorType(model) && resultModel === undefined) {
                resultModel = model;
            }
        });
    }
    let statusMonitor = undefined;
    for (const response of sourceResponses) {
        visitResponse(program, response, undefined, (name, prop) => {
            sourceResponseProperties.set(name, prop);
            handleExplicitParameterMap(prop, "ResponseBody");
            const link = extractPollinglink(prop);
            if (link && !pollingLink) {
                pollingLink = link;
            }
        });
    }
    gatherLroParameters();
    diagnostics.pipe(getStatusMonitorInfo());
    function gatherLroParameters() {
        if (unmatchedParameters.size > 0) {
            for (const [targetName, targetProperty] of targetProperties) {
                getLroParameterFromProperty(targetName, targetProperty, sourceParamProperties, "RequestParameter");
                sourceBodyProperties.size > 0 &&
                    getLroParameterFromProperty(targetName, targetProperty, sourceBodyProperties, "RequestBody");
                sourceResponseProperties.size > 0 &&
                    getLroParameterFromProperty(targetName, targetProperty, sourceResponseProperties, "ResponseBody");
            }
        }
        if (parameters === undefined)
            return;
        for (const [_, parameter] of getAllProperties(parameters)) {
            processModelPropertyFromParameterMap(parameter);
        }
    }
    function getStatusMonitorInfo() {
        let result = undefined;
        const diagnostics = createDiagnosticCollector();
        for (const response of targetResponses) {
            visitResponse(program, response, (m) => {
                const status = getLroStatusProperty(program, m);
                if (status !== undefined) {
                    result = diagnostics.pipe(extractStatusMonitorInfo(program, m, status));
                }
            });
            if (result) {
                break;
            }
        }
        statusMonitor = result;
        return diagnostics.wrap(result);
    }
    function handleExplicitParameterMap(source, kind) {
        const directMapping = getPollingOperationParameter(program, source);
        if (directMapping === undefined)
            return;
        let targetName = directMapping;
        let targetProperty = directMapping;
        if (targetName.length > 0 && targetProperties.has(targetName)) {
            targetProperty = targetProperties.get(targetName);
        }
        targetName = targetProperty.name;
        parameterMap.set(targetName, { source: source, target: targetProperty, sourceKind: kind });
        unmatchedParameters.delete(targetName);
    }
    function getLroParameterFromProperty(targetName, targetProperty, sourceProperties, sourceKind) {
        const sourceProperty = sourceProperties.get(targetName);
        if (sourceProperty !== undefined) {
            parameterMap.set(targetName, {
                sourceKind: sourceKind,
                source: sourceProperty,
                target: targetProperty,
            });
            unmatchedParameters.delete(targetName);
        }
    }
    function visitResponse(program, response, modelAction, modelPropertyAction) {
        function visitModel(model) {
            modelAction && modelAction(model);
            if (modelPropertyAction) {
                for (const [name, prop] of getAllProperties(model)) {
                    modelPropertyAction(name, prop);
                }
            }
        }
        function visitUnion(union) {
            for (const [_, prop] of union.variants) {
                visitVariant(prop);
            }
        }
        function visitVariant(variant) {
            switch (variant.type.kind) {
                case "Model":
                    visitModel(variant.type);
                    break;
                case "Union":
                    visitUnion(variant.type);
                    break;
                default:
                    // do nothing
                    break;
            }
        }
        if (isErrorType(response.type))
            return;
        switch (response.type.kind) {
            case "Model":
                visitModel(response.type);
                break;
            case "Union":
                visitUnion(response.type);
                break;
            default:
            // throw diagnostic
        }
    }
    function processModelPropertyFromParameterMap(property) {
        var _a;
        if (property.type.kind !== "Model") {
            diagnostics.add(createDiagnostic({
                code: "operation-link-parameter-invalid",
                target: sourceOperation,
                format: {},
            }));
            return;
        }
        const propMap = property.type;
        const typeName = propMap.name;
        const namespace = (_a = propMap.namespace) === null || _a === void 0 ? void 0 : _a.name;
        if (namespace !== "Core" ||
            (typeName !== "RequestParameter" && typeName !== "ResponseProperty")) {
            diagnostics.add(createDiagnostic({
                code: "operation-link-parameter-invalid",
                target: sourceOperation,
                format: {},
            }));
            return;
        }
        const targetProperty = targetProperties.get(property.name);
        if (targetProperty === undefined) {
            diagnostics.add(createDiagnostic({
                code: "operation-link-parameter-invalid-target",
                target: targetOperation,
                format: { name: property.name },
            }));
            return;
        }
        const sourceProperty = propMap.templateMapper.args[0];
        switch (sourceProperty.kind) {
            case "String":
                const sourcePropertyName = sourceProperty.value;
                if (typeName === "RequestParameter") {
                    let sourceParam = sourceParamProperties.get(sourcePropertyName);
                    if (sourceParam !== undefined) {
                        unmatchedParameters.delete(property.name);
                        parameterMap.set(property.name, {
                            sourceKind: "RequestParameter",
                            source: sourceParam,
                            target: targetProperty,
                        });
                        return;
                    }
                    sourceParam = sourceBodyProperties.get(sourcePropertyName);
                    if (sourceParam !== undefined) {
                        unmatchedParameters.delete(property.name);
                        parameterMap.set(property.name, {
                            sourceKind: "RequestBody",
                            source: sourceParam,
                            target: targetProperty,
                        });
                        return;
                    }
                    diagnostics.add(createDiagnostic({
                        code: "request-parameter-invalid",
                        target: sourceOperation,
                        format: { name: sourcePropertyName },
                    }));
                    return;
                }
                else if (typeName === "ResponseProperty") {
                    const sourceParam = sourceResponseProperties.get(sourcePropertyName);
                    if (sourceParam === undefined) {
                        diagnostics.add(createDiagnostic({
                            code: "response-property-invalid",
                            target: sourceOperation,
                            format: { name: sourcePropertyName },
                        }));
                        return;
                    }
                    unmatchedParameters.delete(property.name);
                    parameterMap.set(property.name, {
                        source: sourceParam,
                        target: targetProperty,
                        sourceKind: "ResponseBody",
                    });
                }
        }
    }
    function extractPollinglink(property) {
        let isKnownLinkHeader = false;
        if (isHeader(program, property)) {
            const headerName = getHeaderFieldName(program, property).toLowerCase();
            isKnownLinkHeader = headerName === "operation-location";
        }
        if (isPollingLocation(program, property) || isKnownLinkHeader) {
            return {
                kind: "link",
                property: property,
                location: isHeader(program, property) ? "ResponseHeader" : "ResponseBody",
            };
        }
        return undefined;
    }
    function ValidateInfo() {
        return resultModel !== undefined;
    }
    function getInvocationInfo() {
        return {
            operation: targetOperation,
            parameterMap: unmatchedParameters.size < 1 ? parameterMap : undefined,
        };
    }
    function getOperationLink() {
        return pollingLink;
    }
    function getResultInfo() {
        return {
            type: resultModel,
            statusMonitor: statusMonitor,
        };
    }
    return diagnostics.wrap(ValidateInfo() ? { getInvocationInfo, getOperationLink, getResultInfo } : undefined);
}
//# sourceMappingURL=lro-info.js.map