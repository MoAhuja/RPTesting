import { createDiagnostic, createStateSymbol, reportDiagnostic } from "./lib.js";
import { getAllProperties } from "./utils.js";
import { createDiagnosticCollector, getKnownValues, getNamespaceFullName, getTypeName, ignoreDiagnostics, isKey, isNeverType, isStringType, isTemplateDeclarationOrInstance, isVoidType, setTypeSpecNamespace, walkPropertiesInherited, } from "@typespec/compiler";
import { getHttpOperation, getRoutePath } from "@typespec/http";
import { getResourceTypeKey, getSegment, isAutoRoute } from "@typespec/rest";
import { extractStatusMonitorInfo, getLroOperationInfo, } from "./lro-info.js";
/*
 * Constants for polling and final operation links
 */
export const PollingOperationKey = "polling";
export const FinalOperationKey = "final";
// @fixed
const fixedKey = createStateSymbol("fixed");
export function $fixed(context, target) {
    context.program.stateMap(fixedKey).set(target, true);
}
export function isFixed(program, target) {
    return program.stateMap(fixedKey).get(target) !== undefined;
}
// pagedResult
const pagedResultsKey = createStateSymbol("pagedResult");
export function $pagedResult(context, entity) {
    context.program.stateMap(pagedResultsKey).set(entity, true);
}
function findPathToProperty(program, entity, condition, current = []) {
    for (const prop of entity.properties.values()) {
        const match = condition(prop);
        if (match) {
            const segments = [...current, prop.name];
            return {
                property: prop,
                path: segments.join("."),
                segments,
            };
        }
        else {
            if (prop.type.kind === "Model") {
                const items = findPathToProperty(program, prop.type, condition, [...current, prop.name]);
                if (items !== undefined) {
                    return items;
                }
            }
        }
    }
    return undefined;
}
function _getItems(program, entity) {
    return findPathToProperty(program, entity, (prop) => getItems(program, prop) !== undefined);
}
function _getNextLink(program, entity) {
    return findPathToProperty(program, entity, (prop) => getNextLink(program, prop) !== undefined);
}
/**
 * Find all named models that could have been the source of the given
 * property. This includes the named parents of all property sources in a
 * chain.
 */
function getNamedSourceModels(property) {
    var _a;
    if (!property.sourceProperty) {
        return undefined;
    }
    const set = new Set();
    for (let p = property; p; p = p.sourceProperty) {
        if ((_a = p.model) === null || _a === void 0 ? void 0 : _a.name) {
            set.add(p.model);
        }
    }
    return set;
}
/**
 * Retrieves PagedResultMetadata for a model, if available. If passed an
 * operation, this will search the operations return type for any paged
 * response and return the PagedResultMetadata for that response.
 */
export function getPagedResult(program, entity) {
    let metadata = undefined;
    switch (entity.kind) {
        case "Model":
            if (program.stateMap(pagedResultsKey).get(entity)) {
                metadata = { modelType: entity };
                const items = _getItems(program, entity);
                if (items !== undefined) {
                    metadata.itemsProperty = items.property;
                    // eslint-disable-next-line deprecation/deprecation
                    metadata.itemsPath = items.path;
                    metadata.itemsSegments = items.segments;
                }
                const nextLink = _getNextLink(program, entity);
                if (nextLink !== undefined) {
                    metadata.nextLinkProperty = nextLink.property;
                    // eslint-disable-next-line deprecation/deprecation
                    metadata.nextLinkPath = nextLink.path;
                    metadata.nextLinkSegments = nextLink.segments;
                }
                return metadata;
            }
            else if (entity.templateMapper) {
                for (const arg of entity.templateMapper.args) {
                    metadata = getPagedResult(program, arg);
                    if (metadata !== undefined) {
                        break;
                    }
                }
                break;
            }
            else if (entity.name === "") {
                // for anonymous models, get the effective type of the properties to see if any are paged
                // if they are, then the anonymous model is probably paged too
                for (const property of entity.properties.values()) {
                    const sources = getNamedSourceModels(property);
                    if (sources) {
                        for (const source of sources) {
                            const sourceMetadata = getPagedResult(program, source);
                            if (sourceMetadata) {
                                return sourceMetadata;
                            }
                        }
                    }
                }
            }
            if (entity.baseModel) {
                const parentMetadata = getPagedResult(program, entity.baseModel);
                if (parentMetadata) {
                    parentMetadata.modelType = entity;
                    return parentMetadata;
                }
            }
            break;
        case "Operation":
            switch (entity.returnType.kind) {
                case "Union":
                    for (const variant of entity.returnType.variants.values()) {
                        metadata = getPagedResult(program, variant.type);
                        if (metadata !== undefined) {
                            break;
                        }
                    }
                    break;
                case "Model":
                    metadata = getPagedResult(program, entity.returnType);
                    break;
            }
            if (metadata !== undefined) {
                const nextLinkOperation = getOperationLink(program, entity, "nextPage");
                if (nextLinkOperation !== undefined) {
                    metadata.nextLinkOperation = nextLinkOperation.linkedOperation;
                }
            }
    }
    return metadata;
}
const itemsPropertyKey = createStateSymbol("items");
export function $items(context, entity) {
    context.program.stateMap(itemsPropertyKey).set(entity, true);
}
/**
 * Returns `true` if the property is marked with `@items`.
 */
export function getItems(program, entity) {
    return program.stateMap(itemsPropertyKey).get(entity);
}
const nextLinkPropertyKey = createStateSymbol("nextLink");
export function $nextLink(context, entity) {
    context.program.stateMap(nextLinkPropertyKey).set(entity, true);
}
/**
 * Returns `true` if the property is marked with `@nextLink`.
 */
export function getNextLink(program, entity) {
    return program.stateMap(nextLinkPropertyKey).get(entity);
}
const lroStatusKey = createStateSymbol("lroStatus");
export function $lroStatus(context, entity) {
    const [states, diagnostics] = extractLroStates(context.program, entity);
    if (diagnostics.length > 0)
        context.program.reportDiagnostics(diagnostics);
    context.program.stateMap(lroStatusKey).set(entity, states);
}
function storeLroState(program, states, name, enumMember) {
    const expectedStates = [
        ["Succeeded", isLroSucceededState, () => states.succeededState.push(name)],
        ["Failed", isLroFailedState, () => states.failedState.push(name)],
        ["Canceled", isLroCanceledState, () => states.canceledState.push(name)],
    ];
    states.states.push(name);
    for (const [knownState, stateTest, setter] of expectedStates) {
        if (name === knownState || (enumMember && stateTest(program, enumMember))) {
            setter();
            break;
        }
    }
}
export function extractLroStates(program, entity) {
    const result = {
        states: [],
        succeededState: [],
        failedState: [],
        canceledState: [],
    };
    const diagnostics = createDiagnosticCollector();
    if (entity.kind === "ModelProperty") {
        // Call the function recursively on the property type
        return extractLroStates(program, entity.type);
    }
    else if (entity.kind === "Enum") {
        for (const member of entity.members.values()) {
            storeLroState(program, result, member.name, member);
        }
    }
    else if (entity.kind === "Union") {
        for (const variant of entity.variants.values()) {
            const option = variant.type;
            if (option.kind !== "String") {
                diagnostics.add(createDiagnostic({
                    code: "lro-status-union-non-string",
                    target: option,
                    format: {
                        type: option.kind,
                    },
                }));
                return diagnostics.wrap(undefined);
            }
            storeLroState(program, result, option.value);
        }
    }
    else {
        diagnostics.add(createDiagnostic({
            code: "lro-status-property-invalid-type",
            target: entity,
            format: {
                type: entity.kind,
            },
        }));
        return diagnostics.wrap(undefined);
    }
    // Make sure all terminal states have been identified
    const missingStates = [];
    if (result.succeededState.length < 1) {
        missingStates.push("Succeeded");
    }
    if (result.failedState.length < 1) {
        missingStates.push("Failed");
    }
    if (missingStates.length > 0) {
        diagnostics.add(createDiagnostic({
            code: "lro-status-missing",
            target: entity,
            format: {
                states: missingStates.join(", "),
            },
        }));
        return diagnostics.wrap(undefined);
    }
    return diagnostics.wrap(result);
}
/**
 *  Returns the `LongRunningStates` associated with `entity`.
 */
export function getLongRunningStates(program, entity) {
    // Is the type a string with known values?
    if (isStringType(program, entity)) {
        // Check the known values enum for LRO states
        const knownValues = getKnownValues(program, entity);
        return knownValues ? getLongRunningStates(program, knownValues) : undefined;
    }
    // Otherwise just check the type itself
    return program.stateMap(lroStatusKey).get(entity);
}
/**
 * Return the property that contains the lro status
 * @param program The program to process
 * @param target The model to check for lro status
 */
export function getLroStatusProperty(program, target) {
    var _a;
    function getProvisioningState(props) {
        var _a;
        let innerProps = undefined;
        let result = undefined;
        const innerProperty = props.get("properties");
        result = props.get("provisioningState");
        if (result === undefined &&
            innerProperty !== undefined &&
            ((_a = innerProperty.type) === null || _a === void 0 ? void 0 : _a.kind) === "Model") {
            innerProps = getAllProperties(innerProperty.type);
            result = innerProps.get("provisioningState");
        }
        return result;
    }
    const props = getAllProperties(target);
    for (const [_, prop] of props.entries()) {
        let values = program.stateMap(lroStatusKey).get(prop);
        if (values !== undefined)
            return prop;
        if (prop.type.kind === "Enum" || prop.type.kind === "Union") {
            values = program.stateMap(lroStatusKey).get(prop.type);
            if (values !== undefined)
                return prop;
        }
    }
    const statusProp = (_a = props.get("status")) !== null && _a !== void 0 ? _a : getProvisioningState(props);
    if (statusProp) {
        const [states, _] = extractLroStates(program, statusProp);
        if (states !== undefined)
            return statusProp;
    }
    return undefined;
}
//@lroResult
const lroResultKey = createStateSymbol("lroResult");
/**
 * Marks the property in a StatusMonitor that contains the logical result
 * of a successful operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the logical result.
 */
export function $lroResult(context, entity) {
    const { program } = context;
    program.stateMap(lroResultKey).set(entity, entity);
}
/**
 * Gets the logical result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default result property if no other
 * property is marked. (defaults to true)
 */
export function getLroResult(program, entity, useDefault = true) {
    const diagnostics = createDiagnosticCollector();
    let count = 0;
    let resultProperty = undefined;
    let defaultProperty = undefined;
    for (const prop of walkPropertiesInherited(entity)) {
        const candidateProperty = program.stateMap(lroResultKey).get(prop);
        if (candidateProperty !== undefined) {
            resultProperty = candidateProperty;
            count++;
        }
        if (prop.name.toLowerCase() === "result")
            defaultProperty = prop;
    }
    if (count > 1) {
        diagnostics.add(createDiagnostic({
            code: "lro-status-monitor-invalid-result-property",
            target: entity,
            format: { resultType: "result", decorator: "@lroResult" },
        }));
    }
    if (resultProperty === undefined && useDefault)
        resultProperty = defaultProperty;
    if (resultProperty && isNeverType(resultProperty.type))
        resultProperty = undefined;
    return diagnostics.wrap(resultProperty);
}
//@lroErrorResult
const lroErrorResultKey = createStateSymbol("lroErrorResult");
/**
 * Marks the property in a StatusMonitor that contains the error result
 * of a failed operation.
 * @param context The decorator execution context.
 * @param entity The model property that contains the error result.
 */
export function $lroErrorResult(context, entity) {
    const { program } = context;
    program.stateMap(lroErrorResultKey).set(entity, entity);
}
/**
 * Gets the error result property from a StatusMonitor
 * @param program The program to process.
 * @param entity The StatusMonitor model to process.
 * @param useDefault Use the default error property if no other
 * property is marked. (defaults to true)
 */
export function getLroErrorResult(program, entity, useDefault = true) {
    const diagnostics = createDiagnosticCollector();
    let count = 0;
    let resultProperty = undefined;
    let defaultProperty = undefined;
    for (const prop of walkPropertiesInherited(entity)) {
        const candidateProperty = program.stateMap(lroErrorResultKey).get(prop);
        if (candidateProperty !== undefined) {
            resultProperty = candidateProperty;
            count++;
        }
        if (prop.name.toLowerCase() === "error")
            defaultProperty = prop;
    }
    if (count > 1) {
        diagnostics.add(createDiagnostic({
            code: "lro-status-monitor-invalid-result-property",
            target: entity,
            format: { resultType: "error", decorator: "@lroErrorResult" },
        }));
    }
    if (resultProperty === undefined && useDefault)
        resultProperty = defaultProperty;
    return diagnostics.wrap(resultProperty);
}
//@pollingOperationParameter
const pollingParameterKey = createStateSymbol("pollingOperationParameter");
export function $pollingOperationParameter(context, entity, target) {
    const { program } = context;
    let storedValue;
    switch (target === null || target === void 0 ? void 0 : target.kind) {
        case "ModelProperty":
            storedValue = target;
            break;
        case "String":
            storedValue = target.value;
            break;
        default:
            storedValue = undefined;
    }
    program.stateMap(pollingParameterKey).set(entity, storedValue !== null && storedValue !== void 0 ? storedValue : entity.name);
}
export function getPollingOperationParameter(program, entity) {
    return program.stateMap(pollingParameterKey).get(entity);
}
// @lroSucceeded
const lroSucceededKey = createStateSymbol("lroSucceeded");
export function $lroSucceeded(context, entity) {
    context.program.stateSet(lroSucceededKey).add(entity);
}
/**
 *  Returns `true` if the enum member represents a "succeeded" state.
 */
export function isLroSucceededState(program, entity) {
    return program.stateSet(lroSucceededKey).has(entity);
}
// @lroCanceled
const lroCanceledKey = createStateSymbol("lroCanceled");
export function $lroCanceled(context, entity) {
    context.program.stateSet(lroCanceledKey).add(entity);
}
/**
 *  Returns `true` if the enum member represents a "canceled" state.
 */
export function isLroCanceledState(program, entity) {
    return program.stateSet(lroCanceledKey).has(entity);
}
// @lroFailed
const lroFailedKey = createStateSymbol("lroFailed");
export function $lroFailed(context, entity) {
    context.program.stateSet(lroFailedKey).add(entity);
}
/**
 *  Returns `true` if the enum member represents a "failed" state.
 */
export function isLroFailedState(program, entity) {
    return program.stateSet(lroFailedKey).has(entity);
}
// @pollingLocation
const pollingLocationsKey = createStateSymbol("pollingLocations");
const pollingLocationInfoKey = createStateSymbol("pollingLocationInfo");
// keys of the pollingOptions type
const optionsKindKey = "kind";
const finalPropertyKey = "finalProperty";
const pollingModelKey = "pollingModel";
const finalResultKey = "finalResult";
export var pollingOptionsKind;
(function (pollingOptionsKind) {
    pollingOptionsKind["StatusMonitor"] = "statusMonitor";
})(pollingOptionsKind || (pollingOptionsKind = {}));
export function $pollingLocation(context, entity, options) {
    const { program } = context;
    if (options) {
        if (isNeverType(options))
            return;
        const info = extractPollingLocationInfo(program, entity, options);
        if (info) {
            program.stateMap(pollingLocationInfoKey).set(entity, info);
        }
    }
    program.stateSet(pollingLocationsKey).add(entity);
}
/**
 * Gets polling information stored with a field that contains a link to an Lro polling endpoint
 * @param program The program to check
 * @param target The ModelProperty to check for polling info
 */
export function getPollingLocationInfo(program, target) {
    return program.stateMap(pollingLocationInfoKey).get(target);
}
function extractUnionVariantValue(type) {
    if (type.kind === "UnionVariant" && type.type.kind === "String")
        return type.type.value;
    return undefined;
}
function extractPollingLocationInfo(program, target, options) {
    var _a, _b;
    const kind = options.properties.get(optionsKindKey);
    if (kind === undefined)
        return undefined;
    const kindValue = extractUnionVariantValue(kind.type);
    if (kindValue === undefined)
        return undefined;
    const pollingInfo = { target: target };
    const pollingModel = (_a = options.properties.get(pollingModelKey)) === null || _a === void 0 ? void 0 : _a.type;
    if (pollingModel && pollingModel.kind === "Model")
        pollingInfo.pollingModel = pollingModel;
    if (pollingModel && isVoidType(pollingModel))
        pollingInfo.pollingModel = program.checker.voidType;
    const finalResult = (_b = options.properties.get(finalResultKey)) === null || _b === void 0 ? void 0 : _b.type;
    if (finalResult && finalResult.kind === "Model")
        pollingInfo.finalResult = finalResult;
    if (finalResult && isVoidType(finalResult))
        pollingInfo.finalResult = program.checker.voidType;
    switch (kindValue) {
        case pollingOptionsKind.StatusMonitor:
            return extractStatusMonitorLocationInfo(program, options, pollingInfo);
        default:
            return undefined;
    }
}
function extractStatusMonitorLocationInfo(program, options, baseInfo) {
    var _a, _b;
    const kind = options.properties.get(optionsKindKey);
    if (kind === undefined || extractUnionVariantValue(kind.type) !== "statusMonitor")
        return undefined;
    if (baseInfo.pollingModel === undefined || baseInfo.pollingModel.kind === "Intrinsic")
        return undefined;
    const finalProperty = (_a = options.properties.get(finalPropertyKey)) === null || _a === void 0 ? void 0 : _a.type;
    let finalPropertyValue = undefined;
    if (finalProperty && finalProperty.kind === "ModelProperty")
        finalPropertyValue = finalProperty;
    if (finalProperty &&
        finalProperty.kind === "String" &&
        baseInfo.pollingModel.properties.has(finalProperty.value)) {
        finalPropertyValue = baseInfo.pollingModel.properties.get(finalProperty.value);
    }
    if (finalPropertyValue === undefined)
        finalPropertyValue = ignoreDiagnostics(getLroResult(program, baseInfo.pollingModel, true));
    const statusProperty = getLroStatusProperty(program, baseInfo.pollingModel);
    if (statusProperty === undefined)
        return undefined;
    const statusMonitor = ignoreDiagnostics(extractStatusMonitorInfo(program, baseInfo.pollingModel, statusProperty));
    if (statusMonitor === undefined)
        return undefined;
    statusMonitor.successProperty = finalPropertyValue;
    baseInfo.finalResult =
        ((_b = finalPropertyValue === null || finalPropertyValue === void 0 ? void 0 : finalPropertyValue.type) === null || _b === void 0 ? void 0 : _b.kind) === "Model" ? finalPropertyValue.type : program.checker.voidType;
    return {
        kind: pollingOptionsKind.StatusMonitor,
        info: statusMonitor,
        ...baseInfo,
    };
}
/**
 *  Returns `true` if the property is marked with @pollingLocation.
 */
export function isPollingLocation(program, entity) {
    return program.stateSet(pollingLocationsKey).has(entity);
}
// @finalLocation
const finalLocationsKey = createStateSymbol("finalLocations");
const finalLocationResultsKey = createStateSymbol("finalLocationResults");
export function $finalLocation(context, entity, finalResult) {
    const { program } = context;
    if (finalResult !== undefined && isNeverType(finalResult))
        return;
    program.stateSet(finalLocationsKey).add(entity);
    switch (finalResult === null || finalResult === void 0 ? void 0 : finalResult.kind) {
        case "Model":
            program.stateMap(finalLocationResultsKey).set(entity, finalResult);
            break;
        case "Intrinsic":
            if (isVoidType(finalResult)) {
                program.stateMap(finalLocationResultsKey).set(entity, finalResult);
            }
    }
}
/**
 *  Returns `true` if the property is marked with @finalLocation.
 */
export function isFinalLocation(program, entity) {
    return program.stateSet(finalLocationsKey).has(entity);
}
export function getFinalLocationValue(program, entity) {
    return program.stateMap(finalLocationResultsKey).get(entity);
}
export function $omitKeyProperties(context, entity) {
    // Delete any key properties from the model
    for (const [key, prop] of entity.properties) {
        if (isKey(context.program, prop)) {
            entity.properties.delete(key);
        }
    }
}
const operationLinkKey = createStateSymbol("operationLink");
export function $operationLink(context, entity, linkedOperation, linkType, parameters) {
    var _a;
    const { program } = context;
    const [operationInfo, diagnostics] = getLroOperationInfo(program, entity, linkedOperation, parameters);
    if (diagnostics.length > 0) {
        program.reportDiagnostics(diagnostics);
    }
    // An operation may have many operationLinks, so treat them as a collection
    let items = context.program.stateMap(operationLinkKey).get(entity);
    if (items === undefined) {
        items = new Map();
    }
    items.set(linkType, {
        parameters: parameters,
        linkedOperation: linkedOperation,
        linkType: linkType,
        link: operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.getOperationLink(),
        parameterMap: (_a = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.getInvocationInfo()) === null || _a === void 0 ? void 0 : _a.parameterMap,
        result: operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.getResultInfo(),
    });
    context.program.stateMap(operationLinkKey).set(entity, items);
}
/**
 * Returns the `OperationLinkMetadata` for a given operation and link type, or undefined.
 */
export function getOperationLink(program, entity, linkType) {
    const items = program.stateMap(operationLinkKey).get(entity);
    if (items !== undefined) {
        return items.get(linkType);
    }
    return items;
}
/**
 * Returns the collection of `OperationLinkMetadata` for a given operation, if any, or undefined.
 */
export function getOperationLinks(program, entity) {
    return program.stateMap(operationLinkKey).get(entity);
}
export function $pollingOperation(context, target, linkedOperation, parameters) {
    const { program } = context;
    const isValidReturnType = target.returnType.kind === "Model" ||
        (target.returnType.kind === "Union" &&
            [...target.returnType.variants.values()].every((x) => x.type.kind === "Model"));
    if (!isValidReturnType) {
        reportDiagnostic(context.program, {
            code: "polling-operation-return-model",
            target: target,
        });
        return;
    }
    context.call($operationLink, target, linkedOperation, PollingOperationKey, parameters);
    const operationDetails = getOperationLink(program, target, PollingOperationKey);
    if (operationDetails === undefined || operationDetails.result === undefined) {
        reportDiagnostic(context.program, {
            code: "polling-operation-return-model",
            target: target,
        });
        return;
    }
    if (operationDetails.result.statusMonitor === undefined) {
        reportDiagnostic(context.program, {
            code: "polling-operation-no-status-monitor",
            target: linkedOperation,
        });
        return;
    }
    if (operationDetails.result.statusMonitor.terminationInfo.succeededState.length < 1) {
        reportDiagnostic(context.program, {
            code: "polling-operation-no-lro-success",
            target: operationDetails.result.statusMonitor.monitorType,
        });
    }
    if (operationDetails.result.statusMonitor.terminationInfo.failedState.length < 1) {
        reportDiagnostic(context.program, {
            code: "polling-operation-no-lro-failure",
            target: operationDetails.result.statusMonitor.monitorType,
        });
    }
    if (operationDetails.parameterMap === undefined && operationDetails.link === undefined) {
        reportDiagnostic(context.program, {
            code: "polling-operation-no-ref-or-link",
            target: target,
        });
    }
}
export function $finalOperation(context, entity, linkedOperation, parameters) {
    const { program } = context;
    context.call($operationLink, entity, linkedOperation, FinalOperationKey, parameters);
    const operationDetails = getOperationLink(program, entity, FinalOperationKey);
    if (operationDetails === undefined || operationDetails.result === undefined) {
        reportDiagnostic(context.program, {
            code: "invalid-final-operation",
            target: entity,
        });
    }
}
export function $nextPageOperation(context, entity, linkedOperation, parameters) {
    context.call($operationLink, entity, linkedOperation, "nextPage", parameters);
}
const requestParameterKey = createStateSymbol("requestParameter");
export function $requestParameter(context, entity, name) {
    context.program.stateMap(requestParameterKey).set(entity, name);
}
export function getRequestParameter(program, entity) {
    if (entity.type.kind !== "Model")
        return undefined;
    const parameterName = program.stateMap(requestParameterKey).get(entity.type);
    return parameterName;
}
const responsePropertyKey = createStateSymbol("responseParameter");
export function $responseProperty(context, entity, name) {
    context.program.stateMap(responsePropertyKey).set(entity, name);
}
export function getResponseProperty(program, entity) {
    if (entity.type.kind !== "Model")
        return undefined;
    const parameterName = program.stateMap(responsePropertyKey).get(entity.type);
    return parameterName;
}
export function $spreadCustomParameters(context, entity, customizations) {
    var _a;
    const customParameters = (_a = customizations.properties.get("parameters")) === null || _a === void 0 ? void 0 : _a.type;
    if (customParameters) {
        if (customParameters.kind !== "Model") {
            // The constraint checker will have complained about this already.
            return;
        }
        // Copy all parameters into this model type
        // TODO: This needs to use the equivalent of Checker.checkSpreadProperty
        // once a helper method is available
        for (const [key, value] of customParameters.properties) {
            entity.properties.set(key, context.program.checker.cloneType(value, {
                sourceProperty: value,
                model: entity,
            }));
        }
    }
}
export function $spreadCustomResponseProperties(context, entity, customizations) {
    var _a;
    const customResponseProperties = (_a = customizations.properties.get("response")) === null || _a === void 0 ? void 0 : _a.type;
    if (customResponseProperties) {
        if (customResponseProperties.kind !== "Model") {
            // The constraint checker will have complained about this already.
            return;
        }
        // Copy all parameters into this model type
        // TODO: This needs to use the equivalent of Checker.checkSpreadProperty
        // once a helper method is available
        for (const [key, value] of customResponseProperties.properties) {
            entity.properties.set(key, context.program.checker.cloneType(value, {
                sourceProperty: value,
                model: entity,
            }));
        }
    }
}
const resourceOperationKey = createStateSymbol("resourceOperation");
export function $ensureResourceType(context, entity, resourceType) {
    if (resourceType.kind === "TemplateParameter") {
        return;
    }
    // Mark the operation as a resource operation
    context.program.stateSet(resourceOperationKey).add(entity);
    if (resourceType.kind !== "Model") {
        context.program.reportDiagnostic({
            code: "invalid-argument",
            message: `This operation expects a Model for its TResource parameter.`,
            severity: "error",
            target: entity,
        });
        return;
    }
    // If the operation is defined under Azure.Core, ignore these diagnostics.
    // We're only concerned with user-defined operations.
    if (entity.namespace && getNamespaceFullName(entity.namespace).startsWith("Azure.Core")) {
        return;
    }
    const key = getResourceTypeKey(context.program, resourceType);
    if (!key) {
        reportDiagnostic(context.program, {
            code: "invalid-resource-type",
            target: entity,
            messageId: "missingKey",
            format: {
                name: getTypeName(resourceType),
            },
        });
        return;
    }
    if (!getSegment(context.program, key.keyProperty)) {
        reportDiagnostic(context.program, {
            code: "invalid-resource-type",
            target: entity,
            messageId: "missingSegment",
            format: {
                name: getTypeName(resourceType),
            },
        });
    }
}
export function isResourceOperation(program, operation) {
    return program.stateSet(resourceOperationKey).has(operation);
}
const needsRouteKey = createStateSymbol("needsRoute");
export function $needsRoute(context, entity) {
    // If the operation is not templated, add it to the list of operations to
    // check later
    if (entity.node.templateParameters.length === 0) {
        context.program.stateSet(needsRouteKey).add(entity);
    }
}
export function checkRpcRoutes(program) {
    program.stateSet(needsRouteKey).forEach((op) => {
        if (op.node.templateParameters.length === 0 &&
            !isAutoRoute(program, op) &&
            !getRoutePath(program, op)) {
            reportDiagnostic(program, {
                code: "rpc-operation-needs-route",
                target: op,
            });
        }
    });
}
const ensureVerbKey = createStateSymbol("ensureVerb");
export function $ensureVerb(context, entity, templateName, verb) {
    context.program.stateMap(ensureVerbKey).set(entity, [templateName, verb]);
}
export function checkEnsureVerb(program) {
    const opMap = program.stateMap(ensureVerbKey);
    for (const [operation, [templateName, requiredVerb]] of opMap.entries()) {
        if (isTemplateDeclarationOrInstance(operation))
            continue;
        const verb = getHttpOperation(program, operation)[0].verb.toString().toLowerCase();
        const reqVerb = requiredVerb.toLowerCase();
        if (verb !== reqVerb) {
            reportDiagnostic(program, {
                code: "verb-conflict",
                target: operation,
                format: {
                    templateName: templateName,
                    verb: verb.toUpperCase(),
                    requiredVerb: reqVerb.toUpperCase(),
                },
            });
        }
    }
}
const embeddingVectorKey = createStateSymbol("embeddingVector");
/** @internal */
export function $embeddingVector(context, entity, elementType) {
    const metadata = {
        elementType: elementType,
    };
    context.program.stateMap(embeddingVectorKey).set(entity, metadata);
}
/**
 * If the provided model is an embedding vector, returns the appropriate metadata; otherwise,
 * returns undefined.
 * @param model the model to query
 * @returns `EmbeddingVectorMetadata`, if applicable, or undefined.
 */
export function getAsEmbeddingVector(program, model) {
    return program.stateMap(embeddingVectorKey).get(model);
}
setTypeSpecNamespace("Foundations", $omitKeyProperties, $requestParameter, $responseProperty);
setTypeSpecNamespace("Foundations.Private", $spreadCustomResponseProperties, $spreadCustomParameters, $ensureResourceType, $needsRoute, $ensureVerb, $embeddingVector);
//# sourceMappingURL=decorators.js.map