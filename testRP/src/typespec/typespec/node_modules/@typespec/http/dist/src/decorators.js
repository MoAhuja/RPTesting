import { createDiagnosticCollector, getDoc, ignoreDiagnostics, isArrayModelType, reportDeprecated, setTypeSpecNamespace, typespecTypeToJson, validateDecoratorTarget, validateDecoratorUniqueOnNode, } from "@typespec/compiler";
import { HttpStateKeys, createDiagnostic, reportDiagnostic } from "./lib.js";
import { setRoute, setSharedRoute } from "./route.js";
import { getStatusCodesFromType } from "./status-codes.js";
import { extractParamsFromPath } from "./utils.js";
export const namespace = "TypeSpec.Http";
export function $header(context, entity, headerNameOrOptions) {
    var _a, _b;
    const options = {
        type: "header",
        name: entity.name.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
    };
    if (headerNameOrOptions) {
        if (headerNameOrOptions.kind === "String") {
            options.name = headerNameOrOptions.value;
        }
        else {
            const name = (_a = headerNameOrOptions.properties.get("name")) === null || _a === void 0 ? void 0 : _a.type;
            if ((name === null || name === void 0 ? void 0 : name.kind) === "String") {
                options.name = name.value;
            }
            const format = (_b = headerNameOrOptions.properties.get("format")) === null || _b === void 0 ? void 0 : _b.type;
            if ((format === null || format === void 0 ? void 0 : format.kind) === "String") {
                const val = format.value;
                if (val === "csv" ||
                    val === "tsv" ||
                    val === "pipes" ||
                    val === "ssv" ||
                    val === "simple" ||
                    val === "form" ||
                    val === "multi") {
                    options.format = val;
                }
            }
        }
    }
    if (entity.type.kind === "Model" &&
        isArrayModelType(context.program, entity.type) &&
        options.format === undefined) {
        reportDiagnostic(context.program, {
            code: "header-format-required",
            target: context.decoratorTarget,
        });
    }
    context.program.stateMap(HttpStateKeys.header).set(entity, options);
}
export function getHeaderFieldOptions(program, entity) {
    return program.stateMap(HttpStateKeys.header).get(entity);
}
export function getHeaderFieldName(program, entity) {
    var _a;
    return (_a = getHeaderFieldOptions(program, entity)) === null || _a === void 0 ? void 0 : _a.name;
}
export function isHeader(program, entity) {
    return program.stateMap(HttpStateKeys.header).has(entity);
}
export function $query(context, entity, queryNameOrOptions) {
    var _a, _b;
    const options = {
        type: "query",
        name: entity.name,
    };
    if (queryNameOrOptions) {
        if (queryNameOrOptions.kind === "String") {
            options.name = queryNameOrOptions.value;
        }
        else {
            const name = (_a = queryNameOrOptions.properties.get("name")) === null || _a === void 0 ? void 0 : _a.type;
            if ((name === null || name === void 0 ? void 0 : name.kind) === "String") {
                options.name = name.value;
            }
            const format = (_b = queryNameOrOptions.properties.get("format")) === null || _b === void 0 ? void 0 : _b.type;
            if ((format === null || format === void 0 ? void 0 : format.kind) === "String") {
                options.format = format.value; // That value should have already been validated by the TypeSpec dec
            }
        }
    }
    if (entity.type.kind === "Model" &&
        isArrayModelType(context.program, entity.type) &&
        options.format === undefined) {
        reportDiagnostic(context.program, {
            code: "query-format-required",
            target: context.decoratorTarget,
        });
    }
    context.program.stateMap(HttpStateKeys.query).set(entity, options);
}
export function getQueryParamOptions(program, entity) {
    return program.stateMap(HttpStateKeys.query).get(entity);
}
export function getQueryParamName(program, entity) {
    var _a;
    return (_a = getQueryParamOptions(program, entity)) === null || _a === void 0 ? void 0 : _a.name;
}
export function isQueryParam(program, entity) {
    return program.stateMap(HttpStateKeys.query).has(entity);
}
export function $path(context, entity, paramName) {
    const options = {
        type: "path",
        name: paramName !== null && paramName !== void 0 ? paramName : entity.name,
    };
    context.program.stateMap(HttpStateKeys.path).set(entity, options);
}
export function getPathParamOptions(program, entity) {
    return program.stateMap(HttpStateKeys.path).get(entity);
}
export function getPathParamName(program, entity) {
    var _a;
    return (_a = getPathParamOptions(program, entity)) === null || _a === void 0 ? void 0 : _a.name;
}
export function isPathParam(program, entity) {
    return program.stateMap(HttpStateKeys.path).has(entity);
}
export function $body(context, entity) {
    context.program.stateSet(HttpStateKeys.body).add(entity);
}
export function isBody(program, entity) {
    return program.stateSet(HttpStateKeys.body).has(entity);
}
export function $statusCode(context, entity) {
    context.program.stateSet(HttpStateKeys.statusCode).add(entity);
    // eslint-disable-next-line deprecation/deprecation
    setLegacyStatusCodeState(context, entity);
}
/**
 * To not break we keep the legacy behavior of resolving the discrete status code in the decorator and saving them in the state.
 * @deprecated To remove. Added in October 2023 sprint.
 */
function setLegacyStatusCodeState(context, entity) {
    const codes = [];
    if (entity.type.kind === "String") {
        if (validStatusCode(context.program, entity.type.value, entity)) {
            codes.push(entity.type.value);
        }
    }
    else if (entity.type.kind === "Number") {
        if (validStatusCode(context.program, String(entity.type.value), entity)) {
            codes.push(String(entity.type.value));
        }
    }
    else if (entity.type.kind === "Union") {
        for (const variant of entity.type.variants.values()) {
            const option = variant.type;
            if (option.kind === "String") {
                if (validStatusCode(context.program, option.value, option)) {
                    codes.push(option.value);
                }
            }
            else if (option.kind === "Number") {
                if (validStatusCode(context.program, String(option.value), option)) {
                    codes.push(String(option.value));
                }
            }
        }
    }
    // Check status code value: 3 digits with first digit in [1-5]
    // Issue a diagnostic if not valid
    function validStatusCode(program, code, entity) {
        const statusCodePattern = /[1-5][0-9][0-9]/;
        if (code.match(statusCodePattern)) {
            return true;
        }
        reportDiagnostic(program, {
            code: "status-code-invalid",
            target: entity,
            messageId: "value",
        });
        return false;
    }
    context.program.stateMap(HttpStateKeys.statusCode).set(entity, codes);
}
/**
 * @deprecated DO NOT USE, for internal use only.
 */
export function setStatusCode(program, entity, codes) {
    program.stateMap(HttpStateKeys.statusCode).set(entity, codes);
}
export function isStatusCode(program, entity) {
    return program.stateMap(HttpStateKeys.statusCode).has(entity);
}
export function getStatusCodesWithDiagnostics(program, type) {
    return getStatusCodesFromType(program, type, type);
}
export function getStatusCodes(program, entity) {
    return ignoreDiagnostics(getStatusCodesWithDiagnostics(program, entity));
}
// Reference: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
export function getStatusCodeDescription(statusCode) {
    if (typeof statusCode === "object") {
        return rangeDescription(statusCode.start, statusCode.end);
    }
    const statusCodeNumber = typeof statusCode === "string" ? parseInt(statusCode, 10) : statusCode;
    switch (statusCodeNumber) {
        case 200:
            return "The request has succeeded.";
        case 201:
            return "The request has succeeded and a new resource has been created as a result.";
        case 202:
            return "The request has been accepted for processing, but processing has not yet completed.";
        case 204:
            return "There is no content to send for this request, but the headers may be useful. ";
        case 301:
            return "The URL of the requested resource has been changed permanently. The new URL is given in the response.";
        case 304:
            return "The client has made a conditional request and the resource has not been modified.";
        case 400:
            return "The server could not understand the request due to invalid syntax.";
        case 401:
            return "Access is unauthorized.";
        case 403:
            return "Access is forbidden";
        case 404:
            return "The server cannot find the requested resource.";
        case 409:
            return "The request conflicts with the current state of the server.";
        case 412:
            return "Precondition failed.";
        case 503:
            return "Service unavailable.";
    }
    return rangeDescription(statusCodeNumber, statusCodeNumber);
}
function rangeDescription(start, end) {
    if (start >= 100 && end <= 199) {
        return "Informational";
    }
    else if (start >= 200 && end <= 299) {
        return "Successful";
    }
    else if (start >= 300 && end <= 399) {
        return "Redirection";
    }
    else if (start >= 400 && end <= 499) {
        return "Client error";
    }
    else if (start >= 500 && end <= 599) {
        return "Server error";
    }
    return undefined;
}
function setOperationVerb(program, entity, verb) {
    if (entity.kind === "Operation") {
        if (!program.stateMap(HttpStateKeys.verbs).has(entity)) {
            program.stateMap(HttpStateKeys.verbs).set(entity, verb);
        }
        else {
            reportDiagnostic(program, {
                code: "http-verb-duplicate",
                format: { entityName: entity.name },
                target: entity,
            });
        }
    }
    else {
        reportDiagnostic(program, {
            code: "http-verb-wrong-type",
            format: { verb, entityKind: entity.kind },
            target: entity,
        });
    }
}
export function getOperationVerb(program, entity) {
    return program.stateMap(HttpStateKeys.verbs).get(entity);
}
export function $get(context, entity) {
    setOperationVerb(context.program, entity, "get");
}
export function $put(context, entity) {
    setOperationVerb(context.program, entity, "put");
}
export function $post(context, entity) {
    setOperationVerb(context.program, entity, "post");
}
export function $patch(context, entity) {
    setOperationVerb(context.program, entity, "patch");
}
export function $delete(context, entity) {
    setOperationVerb(context.program, entity, "delete");
}
export function $head(context, entity) {
    setOperationVerb(context.program, entity, "head");
}
/**
 * Configure the server url for the service.
 * @param context Decorator context
 * @param target Decorator target(Must be a namespace)
 * @param description Description for this server.
 * @param parameters @optional Parameters to interpolate in the server url.
 */
export function $server(context, target, url, description, parameters) {
    var _a;
    const params = extractParamsFromPath(url);
    const parameterMap = new Map((_a = parameters === null || parameters === void 0 ? void 0 : parameters.properties) !== null && _a !== void 0 ? _a : []);
    for (const declaredParam of params) {
        const param = parameterMap.get(declaredParam);
        if (!param) {
            reportDiagnostic(context.program, {
                code: "missing-server-param",
                format: { param: declaredParam },
                target: context.getArgumentTarget(0),
            });
            parameterMap.delete(declaredParam);
        }
    }
    let servers = context.program.stateMap(HttpStateKeys.servers).get(target);
    if (servers === undefined) {
        servers = [];
        context.program.stateMap(HttpStateKeys.servers).set(target, servers);
    }
    servers.push({
        url,
        description,
        parameters: parameterMap,
    });
}
export function getServers(program, type) {
    return program.stateMap(HttpStateKeys.servers).get(type);
}
export function $plainData(context, entity) {
    const { program } = context;
    const decoratorsToRemove = ["$header", "$body", "$query", "$path", "$statusCode"];
    const [headers, bodies, queries, paths, statusCodes] = [
        program.stateMap(HttpStateKeys.header),
        program.stateSet(HttpStateKeys.body),
        program.stateMap(HttpStateKeys.query),
        program.stateMap(HttpStateKeys.path),
        program.stateMap(HttpStateKeys.statusCode),
    ];
    for (const property of entity.properties.values()) {
        // Remove the decorators so that they do not run in the future, for example,
        // if this model is later spread into another.
        property.decorators = property.decorators.filter((d) => !decoratorsToRemove.includes(d.decorator.name));
        // Remove the impact the decorators already had on this model.
        headers.delete(property);
        bodies.delete(property);
        queries.delete(property);
        paths.delete(property);
        statusCodes.delete(property);
    }
}
setTypeSpecNamespace("Private", $plainData);
export function $useAuth(context, serviceNamespace, authConfig) {
    const [auth, diagnostics] = extractServiceAuthentication(context.program, authConfig);
    if (diagnostics.length > 0)
        context.program.reportDiagnostics(diagnostics);
    if (auth !== undefined) {
        setAuthentication(context.program, serviceNamespace, auth);
    }
}
export function setAuthentication(program, serviceNamespace, auth) {
    program.stateMap(HttpStateKeys.authentication).set(serviceNamespace, auth);
}
function extractServiceAuthentication(program, type) {
    const diagnostics = createDiagnosticCollector();
    switch (type.kind) {
        case "Model":
            const auth = diagnostics.pipe(extractHttpAuthentication(program, type, type));
            if (auth === undefined)
                return diagnostics.wrap(undefined);
            return diagnostics.wrap({ options: [{ schemes: [auth] }] });
        case "Tuple":
            const option = diagnostics.pipe(extractHttpAuthenticationOption(program, type, type));
            return diagnostics.wrap({ options: [option] });
        case "Union":
            return extractHttpAuthenticationOptions(program, type, type);
    }
}
function extractHttpAuthenticationOptions(program, tuple, diagnosticTarget) {
    const options = [];
    const diagnostics = createDiagnosticCollector();
    for (const variant of tuple.variants.values()) {
        const value = variant.type;
        switch (value.kind) {
            case "Model":
                const result = diagnostics.pipe(extractHttpAuthentication(program, value, diagnosticTarget));
                if (result !== undefined) {
                    options.push({ schemes: [result] });
                }
                break;
            case "Tuple":
                const option = diagnostics.pipe(extractHttpAuthenticationOption(program, value, diagnosticTarget));
                options.push(option);
                break;
            default:
                diagnostics.add(createDiagnostic({
                    code: "invalid-type-for-auth",
                    format: { kind: value.kind },
                    target: value,
                }));
        }
    }
    return diagnostics.wrap({ options });
}
function extractHttpAuthenticationOption(program, tuple, diagnosticTarget) {
    const schemes = [];
    const diagnostics = createDiagnosticCollector();
    for (const value of tuple.values) {
        switch (value.kind) {
            case "Model":
                const result = diagnostics.pipe(extractHttpAuthentication(program, value, diagnosticTarget));
                if (result !== undefined) {
                    schemes.push(result);
                }
                break;
            default:
                diagnostics.add(createDiagnostic({
                    code: "invalid-type-for-auth",
                    format: { kind: value.kind },
                    target: value,
                }));
        }
    }
    return diagnostics.wrap({ schemes });
}
function extractHttpAuthentication(program, modelType, diagnosticTarget) {
    const [result, diagnostics] = typespecTypeToJson(modelType, diagnosticTarget);
    if (result === undefined) {
        return [result, diagnostics];
    }
    const description = getDoc(program, modelType);
    const auth = result.type === "oauth2" ? extractOAuth2Auth(result) : result;
    return [
        {
            ...auth,
            id: modelType.name || result.type,
            ...(description && { description }),
        },
        diagnostics,
    ];
}
function extractOAuth2Auth(data) {
    // Validation of OAuth2Flow models in this function is minimal because the
    // type system already validates whether the model represents a flow
    // configuration.  This code merely avoids runtime errors.
    const flows = Array.isArray(data.flows) && data.flows.every((x) => typeof x === "object")
        ? data.flows
        : [];
    return {
        ...data,
        flows: flows.map((flow) => {
            return {
                ...flow,
                scopes: (flow.scopes || []).map((x) => ({ value: x })),
            };
        }),
    };
}
export function getAuthentication(program, namespace) {
    return program.stateMap(HttpStateKeys.authentication).get(namespace);
}
/**
 * `@route` defines the relative route URI for the target operation
 *
 * The first argument should be a URI fragment that may contain one or more path parameter fields.
 * If the namespace or interface that contains the operation is also marked with a `@route` decorator,
 * it will be used as a prefix to the route URI of the operation.
 *
 * `@route` can only be applied to operations, namespaces, and interfaces.
 */
export function $route(context, entity, path, parameters) {
    var _a;
    validateDecoratorUniqueOnNode(context, entity, $route);
    // Handle the deprecated `shared` option
    let shared = false;
    const sharedValue = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.properties.get("shared")) === null || _a === void 0 ? void 0 : _a.type;
    if (sharedValue !== undefined) {
        reportDeprecated(context.program, "The `shared` option is deprecated, use the `@sharedRoute` decorator instead.", entity);
        // The type checker should have raised a diagnostic if the value isn't boolean
        if (sharedValue.kind === "Boolean") {
            shared = sharedValue.value;
        }
    }
    setRoute(context, entity, {
        path,
        shared,
    });
}
/**
 * `@sharedRoute` marks the operation as sharing a route path with other operations.
 *
 * When an operation is marked with `@sharedRoute`, it enables other operations to share the same
 * route path as long as those operations are also marked with `@sharedRoute`.
 *
 * `@sharedRoute` can only be applied directly to operations.
 */
export function $sharedRoute(context, entity) {
    setSharedRoute(context.program, entity);
}
/**
 * Specifies if inapplicable metadata should be included in the payload for
 * the given entity. This is true by default unless changed by this
 * decorator.
 *
 * @param entity Target model, namespace, or model property. If applied to a
 *               model or namespace, applies recursively to child models,
 *               namespaces, and model properties unless overridden by
 *               applying this decorator to a child.
 *
 * @param value `true` to include inapplicable metadata in payload, false to
 *               exclude it.
 *
 * @see isApplicableMetadata
 */
export function $includeInapplicableMetadataInPayload(context, entity, value) {
    if (!validateDecoratorTarget(context, entity, "@includeInapplicableMetadataInPayload", [
        "Namespace",
        "Model",
        "ModelProperty",
    ])) {
        return;
    }
    const state = context.program.stateMap(HttpStateKeys.includeInapplicableMetadataInPayload);
    state.set(entity, value);
}
/**
 * Determines if the given model property should be included in the payload if it is
 * inapplicable metadata.
 *
 * @see isApplicableMetadata
 * @see $includeInapplicableMetadataInPayload
 */
export function includeInapplicableMetadataInPayload(program, property) {
    let e;
    for (e = property; e; e = e.kind === "ModelProperty" ? e.model : e.namespace) {
        const value = program.stateMap(HttpStateKeys.includeInapplicableMetadataInPayload).get(e);
        if (value !== undefined) {
            return value;
        }
    }
    return true;
}
//# sourceMappingURL=decorators.js.map