var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResponseIndex_instances, _ResponseIndex_index, _ResponseIndex_indexKey;
import { createDiagnosticCollector, getDoc, getErrorsDoc, getReturnsDoc, isArrayModelType, isErrorModel, isNullType, isVoidType, walkPropertiesInherited, } from "@typespec/compiler";
import { getContentTypes, isContentTypeHeader } from "./content-types.js";
import { getHeaderFieldName, getStatusCodeDescription, getStatusCodesWithDiagnostics, isBody, isHeader, isStatusCode, } from "./decorators.js";
import { createDiagnostic, HttpStateKeys, reportDiagnostic } from "./lib.js";
import { gatherMetadata, isApplicableMetadata, Visibility } from "./metadata.js";
/**
 * Get the responses for a given operation.
 */
export function getResponsesForOperation(program, operation) {
    const diagnostics = createDiagnosticCollector();
    const responseType = operation.returnType;
    const responses = new ResponseIndex();
    if (responseType.kind === "Union") {
        for (const option of responseType.variants.values()) {
            if (isNullType(option.type)) {
                // TODO how should we treat this? https://github.com/microsoft/typespec/issues/356
                continue;
            }
            processResponseType(program, diagnostics, operation, responses, option.type);
        }
    }
    else {
        processResponseType(program, diagnostics, operation, responses, responseType);
    }
    return diagnostics.wrap(responses.values());
}
/**
 * Class keeping an index of all the response by status code
 */
class ResponseIndex {
    constructor() {
        _ResponseIndex_instances.add(this);
        _ResponseIndex_index.set(this, new Map());
    }
    get(statusCode) {
        return __classPrivateFieldGet(this, _ResponseIndex_index, "f").get(__classPrivateFieldGet(this, _ResponseIndex_instances, "m", _ResponseIndex_indexKey).call(this, statusCode));
    }
    set(statusCode, response) {
        __classPrivateFieldGet(this, _ResponseIndex_index, "f").set(__classPrivateFieldGet(this, _ResponseIndex_instances, "m", _ResponseIndex_indexKey).call(this, statusCode), response);
    }
    values() {
        return [...__classPrivateFieldGet(this, _ResponseIndex_index, "f").values()];
    }
}
_ResponseIndex_index = new WeakMap(), _ResponseIndex_instances = new WeakSet(), _ResponseIndex_indexKey = function _ResponseIndex_indexKey(statusCode) {
    if (typeof statusCode === "number" || statusCode === "*") {
        return String(statusCode);
    }
    else {
        return `${statusCode.start}-${statusCode.end}`;
    }
};
function processResponseType(program, diagnostics, operation, responses, responseType) {
    var _a;
    const metadata = gatherMetadata(program, diagnostics, responseType, Visibility.Read);
    // Get explicity defined status codes
    const statusCodes = diagnostics.pipe(getResponseStatusCodes(program, responseType, metadata));
    // Get explicitly defined content types
    const contentTypes = getResponseContentTypes(program, diagnostics, metadata);
    // Get response headers
    const headers = getResponseHeaders(program, metadata);
    // Get body
    let bodyType = getResponseBody(program, diagnostics, responseType, metadata);
    // If there is no explicit status code, check if it should be 204
    if (statusCodes.length === 0) {
        if (bodyType === undefined || isVoidType(bodyType)) {
            bodyType = undefined;
            statusCodes.push(204);
        }
        else if (isErrorModel(program, responseType)) {
            statusCodes.push("*");
        }
        else {
            statusCodes.push(200);
        }
    }
    // If there is a body but no explicit content types, use application/json
    if (bodyType && contentTypes.length === 0) {
        contentTypes.push("application/json");
    }
    // Put them into currentEndpoint.responses
    for (const statusCode of statusCodes) {
        // the first model for this statusCode/content type pair carries the
        // description for the endpoint. This could probably be improved.
        const response = (_a = responses.get(statusCode)) !== null && _a !== void 0 ? _a : {
            statusCode: typeof statusCode === "object" ? "*" : String(statusCode),
            statusCodes: statusCode,
            type: responseType,
            description: getResponseDescription(program, operation, responseType, statusCode, bodyType),
            responses: [],
        };
        if (bodyType !== undefined) {
            response.responses.push({ body: { contentTypes: contentTypes, type: bodyType }, headers });
        }
        else if (contentTypes.length > 0) {
            diagnostics.add(createDiagnostic({
                code: "content-type-ignored",
                target: responseType,
            }));
        }
        else {
            response.responses.push({ headers });
        }
        responses.set(statusCode, response);
    }
}
/**
 * Get explicity defined status codes from response type and metadata
 * Return is an array of strings, possibly empty, which indicates no explicitly defined status codes.
 * We do not check for duplicates here -- that will be done by the caller.
 */
function getResponseStatusCodes(program, responseType, metadata) {
    const codes = [];
    const diagnostics = createDiagnosticCollector();
    let statusFound = false;
    for (const prop of metadata) {
        if (isStatusCode(program, prop)) {
            if (statusFound) {
                reportDiagnostic(program, {
                    code: "multiple-status-codes",
                    target: responseType,
                });
            }
            statusFound = true;
            codes.push(...diagnostics.pipe(getStatusCodesWithDiagnostics(program, prop)));
        }
    }
    // This is only needed to retrieve the * status code set by @defaultResponse.
    // https://github.com/microsoft/typespec/issues/2485
    if (responseType.kind === "Model") {
        for (let t = responseType; t; t = t.baseModel) {
            codes.push(...getExplicitSetStatusCode(program, t));
        }
    }
    return diagnostics.wrap(codes);
}
function getExplicitSetStatusCode(program, entity) {
    var _a;
    return (_a = program.stateMap(HttpStateKeys.statusCode).get(entity)) !== null && _a !== void 0 ? _a : [];
}
/**
 * Get explicity defined content-types from response metadata
 * Return is an array of strings, possibly empty, which indicates no explicitly defined content-type.
 * We do not check for duplicates here -- that will be done by the caller.
 */
function getResponseContentTypes(program, diagnostics, metadata) {
    const contentTypes = [];
    for (const prop of metadata) {
        if (isHeader(program, prop) && isContentTypeHeader(program, prop)) {
            contentTypes.push(...diagnostics.pipe(getContentTypes(prop)));
        }
    }
    return contentTypes;
}
/**
 * Get response headers from response metadata
 */
function getResponseHeaders(program, metadata) {
    const responseHeaders = {};
    for (const prop of metadata) {
        const headerName = getHeaderFieldName(program, prop);
        if (isHeader(program, prop) && headerName !== "content-type") {
            responseHeaders[headerName] = prop;
        }
    }
    return responseHeaders;
}
function getResponseBody(program, diagnostics, responseType, metadata) {
    // non-model or intrinsic/array model -> response body is response type
    if (responseType.kind !== "Model" || isArrayModelType(program, responseType)) {
        return responseType;
    }
    // look for explicit body
    let bodyProperty;
    for (const property of metadata) {
        if (isBody(program, property)) {
            if (bodyProperty) {
                diagnostics.add(createDiagnostic({ code: "duplicate-body", target: property }));
            }
            else {
                bodyProperty = property;
            }
        }
    }
    if (bodyProperty) {
        return bodyProperty.type;
    }
    // Without an explicit body, response type is response model itself if
    // there it has at least one non-metadata property, if it is an empty object or if it has derived
    // models
    if (responseType.derivedModels.length > 0 || responseType.properties.size === 0) {
        return responseType;
    }
    for (const property of walkPropertiesInherited(responseType)) {
        if (!isApplicableMetadata(program, property, Visibility.Read)) {
            return responseType;
        }
    }
    // Otherwise, there is no body
    return undefined;
}
function getResponseDescription(program, operation, responseType, statusCode, bodyType) {
    // NOTE: If the response type is an envelope and not the same as the body
    // type, then use its @doc as the response description. However, if the
    // response type is the same as the body type, then use the default status
    // code description and don't duplicate the schema description of the body
    // as the response description. This allows more freedom to change how
    // TypeSpec is expressed in semantically equivalent ways without causing
    // the output to change unnecessarily.
    if (responseType !== bodyType) {
        const desc = getDoc(program, responseType);
        if (desc) {
            return desc;
        }
    }
    const desc = isErrorModel(program, responseType)
        ? getErrorsDoc(program, operation)
        : getReturnsDoc(program, operation);
    if (desc) {
        return desc;
    }
    return getStatusCodeDescription(statusCode);
}
//# sourceMappingURL=responses.js.map