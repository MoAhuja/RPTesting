import { compilerAssert, createDiagnosticCollector } from "./diagnostics.js";
import { getLocationContext } from "./helpers/index.js";
import { createDiagnostic } from "./messages.js";
import { EventEmitter, mapEventEmitterToNodeListener, navigateProgram } from "./semantic-walker.js";
import { NoTarget, } from "./types.js";
export function createLinter(program, loadLibrary) {
    const tracer = program.tracer.sub("linter");
    const ruleMap = new Map();
    const enabledRules = new Map();
    const linterLibraries = new Map();
    return {
        extendRuleSet,
        lint,
    };
    function getLinterDefinition(library) {
        var _a, _b;
        // eslint-disable-next-line deprecation/deprecation
        return (_a = library === null || library === void 0 ? void 0 : library.linter) !== null && _a !== void 0 ? _a : (_b = library === null || library === void 0 ? void 0 : library.definition) === null || _b === void 0 ? void 0 : _b.linter;
    }
    async function extendRuleSet(ruleSet) {
        var _a;
        tracer.trace("extend-rule-set.start", JSON.stringify(ruleSet, null, 2));
        const diagnostics = createDiagnosticCollector();
        if (ruleSet.extends) {
            for (const extendingRuleSetName of ruleSet.extends) {
                const ref = diagnostics.pipe(parseRuleReference(extendingRuleSetName));
                if (ref) {
                    const library = await resolveLibrary(ref.libraryName);
                    const libLinterDefinition = library && getLinterDefinition(library);
                    const extendingRuleSet = (_a = libLinterDefinition === null || libLinterDefinition === void 0 ? void 0 : libLinterDefinition.ruleSets) === null || _a === void 0 ? void 0 : _a[ref.name];
                    if (extendingRuleSet) {
                        await extendRuleSet(extendingRuleSet);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule-set",
                            format: { libraryName: ref.libraryName, ruleSetName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        const enabledInThisRuleSet = new Set();
        if (ruleSet.enable) {
            for (const [ruleName, enable] of Object.entries(ruleSet.enable)) {
                if (enable === false) {
                    continue;
                }
                const ref = diagnostics.pipe(parseRuleReference(ruleName));
                if (ref) {
                    await resolveLibrary(ref.libraryName);
                    const rule = ruleMap.get(ruleName);
                    if (rule) {
                        enabledInThisRuleSet.add(ruleName);
                        enabledRules.set(ruleName, rule);
                    }
                    else {
                        diagnostics.add(createDiagnostic({
                            code: "unknown-rule",
                            format: { libraryName: ref.libraryName, ruleName: ref.name },
                            target: NoTarget,
                        }));
                    }
                }
            }
        }
        if (ruleSet.disable) {
            for (const ruleName of Object.keys(ruleSet.disable)) {
                if (enabledInThisRuleSet.has(ruleName)) {
                    diagnostics.add(createDiagnostic({
                        code: "rule-enabled-disabled",
                        format: { ruleName },
                        target: NoTarget,
                    }));
                }
                enabledRules.delete(ruleName);
            }
        }
        tracer.trace("extend-rule-set.end", "Rules enabled: \n" + [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        return diagnostics.diagnostics;
    }
    function lint() {
        const diagnostics = createDiagnosticCollector();
        const eventEmitter = new EventEmitter();
        tracer.trace("lint", `Running linter with following rules:\n` +
            [...enabledRules.keys()].map((x) => ` - ${x}`).join("\n"));
        for (const rule of enabledRules.values()) {
            const listener = rule.create(createLinterRuleContext(program, rule, diagnostics));
            for (const [name, cb] of Object.entries(listener)) {
                eventEmitter.on(name, cb);
            }
        }
        navigateProgram(program, mapEventEmitterToNodeListener(eventEmitter));
        return diagnostics.diagnostics;
    }
    async function resolveLibrary(name) {
        const loadedLibrary = linterLibraries.get(name);
        if (loadedLibrary === undefined) {
            return registerLinterLibrary(name);
        }
        return loadedLibrary;
    }
    async function registerLinterLibrary(name) {
        tracer.trace("register-library", name);
        const library = await loadLibrary(name);
        const linter = library && getLinterDefinition(library);
        if (linter === null || linter === void 0 ? void 0 : linter.rules) {
            for (const ruleDef of linter.rules) {
                const ruleId = `${name}/${ruleDef.name}`;
                tracer.trace("register-library.rule", `Registering rule "${ruleId}" for library "${name}".`);
                const rule = { ...ruleDef, id: ruleId };
                if (ruleMap.has(ruleId)) {
                    compilerAssert(false, `Unexpected duplicate linter rule: "${ruleId}"`);
                }
                else {
                    ruleMap.set(ruleId, rule);
                }
            }
        }
        linterLibraries.set(name, library);
        return library;
    }
    function parseRuleReference(ref) {
        const segments = ref.split("/");
        const name = segments.pop();
        const libraryName = segments.join("/");
        if (!libraryName || !name) {
            return [
                undefined,
                [createDiagnostic({ code: "invalid-rule-ref", format: { ref }, target: NoTarget })],
            ];
        }
        return [{ libraryName, name }, []];
    }
}
export function createLinterRuleContext(program, rule, diagnosticCollector) {
    return {
        program,
        reportDiagnostic,
    };
    function createDiagnostic(diag) {
        var _a;
        const message = rule.messages[(_a = diag.messageId) !== null && _a !== void 0 ? _a : "default"];
        if (!message) {
            const messageString = Object.keys(rule.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diag.messageId);
            throw new Error(`Unexpected message id '${messageId}' for rule '${rule.name}'. Defined messages:\n${messageString}`);
        }
        const messageStr = typeof message === "string" ? message : message(diag.format);
        return {
            code: rule.id,
            severity: rule.severity,
            message: messageStr,
            target: diag.target,
        };
    }
    function reportDiagnostic(diag) {
        const diagnostic = createDiagnostic(diag);
        if (diagnostic.target !== NoTarget) {
            const context = getLocationContext(program, diagnostic.target);
            // Only report diagnostic in the user project.
            // See for showing diagnostic in library at point of usage https://github.com/microsoft/typespec/issues/1997
            if (context.type === "project") {
                diagnosticCollector.add(diagnostic);
            }
        }
    }
}
//# sourceMappingURL=linter.js.map