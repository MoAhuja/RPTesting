import { compilerAssert, SyntaxKind, } from "../core/index.js";
import { getDocData } from "../lib/decorators.js";
import { getSymbolSignature } from "./type-signature.js";
/**
 * Get the detailed documentation for a symbol.
 * @param program The program
 * @internal
 */
export function getSymbolDetails(program, symbol, options = {
    includeSignature: true,
    includeParameterTags: true,
}) {
    var _a;
    const lines = [];
    if (options.includeSignature) {
        lines.push(getSymbolSignature(program, symbol));
    }
    const doc = getSymbolDocumentation(program, symbol);
    if (doc) {
        lines.push(doc);
    }
    for (const node of symbol.declarations) {
        for (const doc of (_a = node === null || node === void 0 ? void 0 : node.docs) !== null && _a !== void 0 ? _a : []) {
            for (const tag of doc.tags) {
                if (!options.includeParameterTags &&
                    (tag.kind === SyntaxKind.DocParamTag || tag.kind === SyntaxKind.DocTemplateTag)) {
                    continue;
                }
                lines.push(
                //prettier-ignore
                `_@${tag.tagName.sv}_${"paramName" in tag ? ` \`${tag.paramName.sv}\`` : ""} â€”\n${getDocContent(tag.content)}`);
            }
        }
    }
    return lines.join("\n\n");
}
function getSymbolDocumentation(program, symbol) {
    var _a, _b;
    const docs = [];
    for (const node of symbol.declarations) {
        // Add /** ... */ developer docs
        for (const d of (_a = node.docs) !== null && _a !== void 0 ? _a : []) {
            docs.push(getDocContent(d.content));
        }
    }
    // Add @doc(...) API docs
    const type = (_b = symbol.type) !== null && _b !== void 0 ? _b : program.checker.getTypeForNode(symbol.declarations[0]);
    const apiDocs = getDocData(program, type);
    // The doc comment is already included above we don't want to duplicate
    if (apiDocs && apiDocs.source === "comment") {
        docs.push(apiDocs.value);
    }
    return docs.join("\n\n");
}
/** @internal */
export function getParameterDocumentation(program, type) {
    var _a, _b;
    const map = new Map();
    for (const d of (_b = (_a = type === null || type === void 0 ? void 0 : type.node) === null || _a === void 0 ? void 0 : _a.docs) !== null && _b !== void 0 ? _b : []) {
        for (const tag of d.tags) {
            if (tag.kind === SyntaxKind.DocParamTag) {
                map.set(tag.paramName.sv, getDocContent(tag.content));
            }
        }
    }
    return map;
}
/** @internal */
export function getTemplateParameterDocumentation(node) {
    var _a;
    const map = new Map();
    for (const d of (_a = node === null || node === void 0 ? void 0 : node.docs) !== null && _a !== void 0 ? _a : []) {
        for (const tag of d.tags) {
            if (tag.kind === SyntaxKind.DocTemplateTag) {
                map.set(tag.paramName.sv, getDocContent(tag.content));
            }
        }
    }
    return map;
}
function getDocContent(content) {
    const docs = [];
    for (const node of content) {
        compilerAssert(node.kind === SyntaxKind.DocText, "No other doc content node kinds exist yet. Update this code appropriately when more are added.");
        docs.push(node.text);
    }
    return docs.join("");
}
//# sourceMappingURL=type-details.js.map