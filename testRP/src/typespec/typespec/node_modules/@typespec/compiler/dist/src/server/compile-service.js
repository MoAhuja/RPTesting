import { DiagnosticSeverity, Range } from "vscode-languageserver";
import { defaultConfig, findTypeSpecConfigPath, loadTypeSpecConfigFile, } from "../config/config-loader.js";
import { resolveOptionsFromConfig } from "../config/config-to-options.js";
import { compilerAssert, formatDiagnostic, getDirectoryPath, joinPaths, parse, } from "../core/index.js";
import { compile as compileProgram } from "../core/program.js";
import { doIO, loadFile, resolveTspMain } from "../core/util.js";
import { serverOptions } from "./constants.js";
import { UpdateManger } from "./update-manager.js";
export function createCompileService({ compilerHost, serverHost, fileService, fileSystemCache, log, }) {
    const oldPrograms = new Map();
    const eventListeners = new Map();
    const updated = new UpdateManger((document) => compile(document));
    return { compile, getScript, on, notifyChange };
    function on(event, listener) {
        eventListeners.set(event, listener);
    }
    function notify(event, ...args) {
        const listener = eventListeners.get(event);
        if (listener) {
            listener(...args);
        }
    }
    function notifyChange(document) {
        updated.scheduleUpdate(document);
    }
    async function compile(document) {
        const path = await fileService.getPath(document);
        const mainFile = await getMainFileForDocument(path);
        const config = await getConfig(mainFile);
        const [optionsFromConfig, _] = resolveOptionsFromConfig(config, { cwd: path });
        const options = {
            ...optionsFromConfig,
            ...serverOptions,
        };
        if (!fileService.upToDate(document)) {
            return undefined;
        }
        let program;
        try {
            program = await compileProgram(compilerHost, mainFile, options, oldPrograms.get(mainFile));
            oldPrograms.set(mainFile, program);
            if (!fileService.upToDate(document)) {
                return undefined;
            }
            if (mainFile !== path && !program.sourceFiles.has(path)) {
                // If the file that changed wasn't imported by anything from the main
                // file, retry using the file itself as the main file.
                program = await compileProgram(compilerHost, path, options, oldPrograms.get(path));
                oldPrograms.set(path, program);
            }
            if (!fileService.upToDate(document)) {
                return undefined;
            }
            const doc = "version" in document ? document : serverHost.getOpenDocumentByURL(document.uri);
            compilerAssert(doc, "Failed to get document.");
            const resolvedPath = await fileService.getPath(doc);
            const script = program.sourceFiles.get(resolvedPath);
            compilerAssert(script, "Failed to get script.");
            const result = { program, document: doc, script };
            notify("compileEnd", result);
            return result;
        }
        catch (err) {
            if (serverHost.throwInternalErrors) {
                throw err;
            }
            serverHost.sendDiagnostics({
                uri: document.uri,
                diagnostics: [
                    {
                        severity: DiagnosticSeverity.Error,
                        range: Range.create(0, 0, 0, 0),
                        message: `Internal compiler error!\nFile issue at https://github.com/microsoft/typespec\n\n` +
                            err.stack,
                    },
                ],
            });
            return undefined;
        }
    }
    async function getConfig(mainFile) {
        const entrypointStat = await compilerHost.stat(mainFile);
        const lookupDir = entrypointStat.isDirectory() ? mainFile : getDirectoryPath(mainFile);
        const configPath = await findTypeSpecConfigPath(compilerHost, lookupDir, true);
        if (!configPath) {
            return { ...defaultConfig, projectRoot: getDirectoryPath(mainFile) };
        }
        const cached = await fileSystemCache.get(configPath);
        if (cached === null || cached === void 0 ? void 0 : cached.data) {
            return cached.data;
        }
        const config = await loadTypeSpecConfigFile(compilerHost, configPath);
        await fileSystemCache.setData(configPath, config);
        return config;
    }
    async function getScript(document) {
        var _a, _b;
        const file = await compilerHost.readFile(await fileService.getPath(document));
        const cached = (_a = compilerHost.parseCache) === null || _a === void 0 ? void 0 : _a.get(file);
        if (cached === undefined) {
            const parsed = parse(file, { docs: true, comments: true });
            (_b = compilerHost.parseCache) === null || _b === void 0 ? void 0 : _b.set(file, parsed);
            return parsed;
        }
        else {
            return cached;
        }
    }
    /**
     * Infer the appropriate entry point (a.k.a. "main file") for analyzing a
     * change to the file at the given path. This is necessary because different
     * results can be obtained from compiling the same file with different entry
     * points.
     *
     * Walk directory structure upwards looking for package.json with tspMain or
     * main.tsp file. Stop search when reaching a workspace root. If a root is
     * reached without finding an entry point, use the given path as its own
     * entry point.
     *
     * Untitled documents are always treated as their own entry points as they
     * do not exist in a directory that could pull them in via another entry
     * point.
     */
    async function getMainFileForDocument(path) {
        if (path.startsWith("untitled:")) {
            return path;
        }
        let dir = getDirectoryPath(path);
        const options = { allowFileNotFound: true };
        while (true) {
            let mainFile = "main.tsp";
            let pkg;
            const pkgPath = joinPaths(dir, "package.json");
            const cached = await fileSystemCache.get(pkgPath);
            if (cached === null || cached === void 0 ? void 0 : cached.data) {
                pkg = cached.data;
            }
            else {
                [pkg] = await loadFile(compilerHost, pkgPath, JSON.parse, logMainFileSearchDiagnostic, options);
                await fileSystemCache.setData(pkgPath, pkg !== null && pkg !== void 0 ? pkg : {});
            }
            const tspMain = resolveTspMain(pkg);
            if (typeof tspMain === "string") {
                mainFile = tspMain;
            }
            const candidate = joinPaths(dir, mainFile);
            const stat = await doIO(() => compilerHost.stat(candidate), candidate, logMainFileSearchDiagnostic, options);
            if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                return candidate;
            }
            const parentDir = getDirectoryPath(dir);
            if (parentDir === dir) {
                break;
            }
            dir = parentDir;
        }
        return path;
        function logMainFileSearchDiagnostic(diagnostic) {
            log(`Unexpected diagnostic while looking for main file of ${path}`, formatDiagnostic(diagnostic));
        }
    }
}
//# sourceMappingURL=compile-service.js.map