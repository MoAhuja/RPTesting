import { stringify } from "yaml";
import { TypeSpecConfigFilename } from "../config/config-loader.js";
import { formatTypeSpec } from "../core/formatter.js";
import { getDirectoryPath, joinPaths } from "../core/path-utils.js";
import { readUrlOrPath, resolveRelativeUrlOrPath } from "../core/util.js";
import { createFileTemplatingContext, render } from "./file-templating.js";
export function normalizeLibrary(library) {
    if (typeof library === "string") {
        return { name: library };
    }
    return library;
}
export function makeScaffoldingConfig(template, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        template,
        libraries: (_c = (_a = config.libraries) !== null && _a !== void 0 ? _a : (_b = template.libraries) === null || _b === void 0 ? void 0 : _b.map(normalizeLibrary)) !== null && _c !== void 0 ? _c : [],
        baseUri: (_d = config.baseUri) !== null && _d !== void 0 ? _d : ".",
        name: (_e = config.name) !== null && _e !== void 0 ? _e : "",
        directory: (_f = config.directory) !== null && _f !== void 0 ? _f : "",
        folderName: (_g = config.folderName) !== null && _g !== void 0 ? _g : "",
        parameters: (_h = config.parameters) !== null && _h !== void 0 ? _h : {},
        ...config,
    };
}
/**
 * Scaffold a new TypeSpec project using the given scaffolding config.
 * @param host
 * @param config
 */
export async function scaffoldNewProject(host, config) {
    await host.mkdirp(config.directory);
    await writePackageJson(host, config);
    await writeConfig(host, config);
    await writeMain(host, config);
    await writeFiles(host, config);
}
function isFileSkipGeneration(fileName, files) {
    var _a;
    for (const file of files) {
        if (file.destination === fileName) {
            return (_a = file.skipGeneration) !== null && _a !== void 0 ? _a : false;
        }
    }
    return false;
}
async function writePackageJson(host, config) {
    var _a;
    if (isFileSkipGeneration("package.json", (_a = config.template.files) !== null && _a !== void 0 ? _a : [])) {
        return;
    }
    const dependencies = {};
    if (!config.template.skipCompilerPackage) {
        dependencies["@typespec/compiler"] = "latest";
    }
    for (const library of config.libraries) {
        dependencies[library.name] = await getLibraryVersion(library);
    }
    const packageJson = {
        name: config.name,
        version: "0.1.0",
        type: "module",
        dependencies,
        private: true,
    };
    return host.writeFile(joinPaths(config.directory, "package.json"), JSON.stringify(packageJson, null, 2));
}
const placeholderConfig = `
# extends: ../tspconfig.yaml                    # Extend another config file
# emit:                                         # Emitter name
#   - "<emitter-name"
# options:                                      # Emitter options
#   <emitter-name>:
#    "<option-name>": "<option-value>"
# environment-variables:                        # Environment variables which can be used to interpolate emitter options
#   <variable-name>:
#     default: "<variable-default>"
# parameters:                                   # Parameters which can be used to interpolate emitter options
#   <param-name>:
#     default: "<param-default>"
# trace:                                        # Trace areas to enable tracing
#  - "<trace-name>"
# warn-as-error: true                           # Treat warnings as errors
# output-dir: "{project-root}/_generated"       # Configure the base output directory for all emitters
`.trim();
async function writeConfig(host, config) {
    var _a;
    if (isFileSkipGeneration(TypeSpecConfigFilename, (_a = config.template.files) !== null && _a !== void 0 ? _a : [])) {
        return;
    }
    const content = config.template.config ? stringify(config.template.config) : placeholderConfig;
    return host.writeFile(joinPaths(config.directory, TypeSpecConfigFilename), content);
}
async function writeMain(host, config) {
    var _a;
    if (isFileSkipGeneration("main.tsp", (_a = config.template.files) !== null && _a !== void 0 ? _a : [])) {
        return;
    }
    const dependencies = {};
    for (const library of config.libraries) {
        dependencies[library.name] = await getLibraryVersion(library);
    }
    const lines = [...config.libraries.map((x) => `import "${x.name}";`), ""];
    const content = lines.join("\n");
    return host.writeFile(joinPaths(config.directory, "main.tsp"), await formatTypeSpec(content));
}
async function writeFiles(host, config) {
    const templateContext = createFileTemplatingContext(config);
    if (!config.template.files) {
        return;
    }
    for (const file of config.template.files) {
        if (file.skipGeneration !== true) {
            await writeFile(host, config, templateContext, file);
        }
    }
}
async function writeFile(host, config, context, file) {
    const baseDir = config.baseUri + "/";
    const template = await readUrlOrPath(host, resolveRelativeUrlOrPath(baseDir, file.path));
    const content = render(template.text, context);
    const destinationFilePath = joinPaths(config.directory, file.destination);
    // create folders in case they don't exist
    await host.mkdirp(getDirectoryPath(destinationFilePath) + "/");
    return host.writeFile(joinPaths(config.directory, file.destination), content);
}
async function getLibraryVersion(library) {
    var _a;
    // TODO: Resolve 'latest' version from npm, issue #1919
    return (_a = library.version) !== null && _a !== void 0 ? _a : "latest";
}
//# sourceMappingURL=scaffold.js.map