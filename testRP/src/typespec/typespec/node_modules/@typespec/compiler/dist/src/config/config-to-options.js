import { createDiagnosticCollector, getDirectoryPath, normalizePath } from "../core/index.js";
import { deepClone, doIO, omitUndefined } from "../core/util.js";
import { expandConfigVariables } from "./config-interpolation.js";
import { loadTypeSpecConfigForPath, validateConfigPathsAbsolute } from "./config-loader.js";
/**
 * Resolve the compiler options for the given entrypoint by resolving the tspconfig.yaml.
 * @param host Compiler host
 * @param compilerOptions
 */
export async function resolveCompilerOptions(host, options) {
    var _a;
    const diagnostics = createDiagnosticCollector();
    const entrypointStat = await doIO(host.stat, options.entrypoint, (diag) => diagnostics.add(diag), { allowFileNotFound: true });
    const configPath = (_a = options.configPath) !== null && _a !== void 0 ? _a : ((entrypointStat === null || entrypointStat === void 0 ? void 0 : entrypointStat.isDirectory()) ? options.entrypoint : getDirectoryPath(options.entrypoint));
    const config = await loadTypeSpecConfigForPath(host, configPath, options.configPath !== undefined, options.configPath === undefined);
    config.diagnostics.forEach((x) => diagnostics.add(x));
    const compilerOptions = diagnostics.pipe(resolveOptionsFromConfig(config, options));
    return diagnostics.wrap(compilerOptions);
}
/**
 * Resolve the compiler options from the given raw TypeSpec config
 * @param config TypeSpec config.
 * @param options Options for interpolation in the config.
 * @returns
 */
export function resolveOptionsFromConfig(config, options) {
    var _a, _b, _c;
    const cwd = normalizePath(options.cwd);
    const diagnostics = createDiagnosticCollector();
    const configWithOverrides = {
        ...config,
        ...options.overrides,
        options: mergeOptions(config.options, (_a = options.overrides) === null || _a === void 0 ? void 0 : _a.options),
    };
    const expandedConfig = diagnostics.pipe(expandConfigVariables(configWithOverrides, {
        cwd,
        outputDir: (_b = options.overrides) === null || _b === void 0 ? void 0 : _b.outputDir,
        env: (_c = options.env) !== null && _c !== void 0 ? _c : {},
        args: options.args,
    }));
    validateConfigPathsAbsolute(expandedConfig).forEach((x) => diagnostics.add(x));
    const resolvedOptions = omitUndefined({
        outputDir: expandedConfig.outputDir,
        config: config.filename,
        configFile: config,
        additionalImports: expandedConfig["imports"],
        warningAsError: expandedConfig.warnAsError,
        trace: expandedConfig.trace,
        emit: expandedConfig.emit,
        options: expandedConfig.options,
        linterRuleSet: expandedConfig.linter,
    });
    return diagnostics.wrap(resolvedOptions);
}
function mergeOptions(base, overrides) {
    var _a;
    const configuredEmitters = deepClone(base !== null && base !== void 0 ? base : {});
    for (const [emitterName, cliOptionOverride] of Object.entries(overrides !== null && overrides !== void 0 ? overrides : {})) {
        configuredEmitters[emitterName] = {
            ...((_a = configuredEmitters[emitterName]) !== null && _a !== void 0 ? _a : {}),
            ...cliOptionOverride,
        };
    }
    return configuredEmitters;
}
//# sourceMappingURL=config-to-options.js.map