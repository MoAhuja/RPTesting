import { DiagnosticSeverity, DiagnosticTag, DocumentHighlightKind, MarkupKind, Range, SemanticTokensBuilder, TextDocumentSyncKind, TextEdit, Diagnostic as VSDiagnostic, } from "vscode-languageserver/node.js";
import { codePointBefore, isIdentifierContinue } from "../core/charcode.js";
import { compilerAssert, createSourceFile, getSourceLocation } from "../core/diagnostics.js";
import { formatTypeSpec } from "../core/formatter.js";
import { getTypeName } from "../core/helpers/type-name-utils.js";
import { getNodeAtPosition, visitChildren } from "../core/parser.js";
import { ensureTrailingDirectorySeparator } from "../core/path-utils.js";
import { skipTrivia, skipWhiteSpace } from "../core/scanner.js";
import { SyntaxKind, } from "../core/types.js";
import { getNormalizedRealPath, getSourceFileKindFromExt } from "../core/util.js";
import { getSemanticTokens } from "./classify.js";
import { createCompileService } from "./compile-service.js";
import { resolveCompletion } from "./completion.js";
import { createFileService } from "./file-service.js";
import { createFileSystemCache } from "./file-system-cache.js";
import { getPositionBeforeTrivia } from "./server-utils.js";
import { getSymbolStructure } from "./symbol-structure.js";
import { getParameterDocumentation, getSymbolDetails, getTemplateParameterDocumentation, } from "./type-details.js";
import { SemanticTokenKind, } from "./types.js";
export function createServer(host) {
    const fileService = createFileService({ serverHost: host });
    // Cache all file I/O. Only open documents are sent over the LSP pipe. When
    // the compiler reads a file that isn't open, we use this cache to avoid
    // hitting the disk. Entries are invalidated when LSP client notifies us of
    // a file change.
    const fileSystemCache = createFileSystemCache({
        fileService,
    });
    const compilerHost = createCompilerHost();
    const compileService = createCompileService({
        fileService,
        fileSystemCache,
        compilerHost,
        serverHost: host,
        log,
    });
    compileService.on("compileEnd", (result) => reportDiagnostics(result));
    let workspaceFolders = [];
    let isInitialized = false;
    let pendingMessages = [];
    return {
        get pendingMessages() {
            return pendingMessages;
        },
        get workspaceFolders() {
            return workspaceFolders;
        },
        compile: compileService.compile,
        initialize,
        initialized,
        workspaceFoldersChanged,
        watchedFilesChanged,
        formatDocument,
        gotoDefinition,
        documentClosed,
        complete,
        findReferences,
        findDocumentHighlight,
        prepareRename,
        rename,
        getSemanticTokens: getSemanticTokensForDocument,
        buildSemanticTokens,
        checkChange,
        getFoldingRanges,
        getHover,
        getSignatureHelp,
        getDocumentSymbols,
        log,
    };
    async function initialize(params) {
        var _a, _b;
        const tokenLegend = {
            tokenTypes: Object.keys(SemanticTokenKind)
                .filter((x) => Number.isNaN(Number(x)))
                .map((x) => x.slice(0, 1).toLocaleLowerCase() + x.slice(1)),
            tokenModifiers: [],
        };
        const capabilities = {
            textDocumentSync: TextDocumentSyncKind.Incremental,
            definitionProvider: true,
            foldingRangeProvider: true,
            hoverProvider: true,
            documentSymbolProvider: true,
            documentHighlightProvider: true,
            completionProvider: {
                resolveProvider: false,
                triggerCharacters: [".", "@", "/"],
            },
            semanticTokensProvider: {
                full: true,
                legend: tokenLegend,
            },
            referencesProvider: true,
            renameProvider: {
                prepareProvider: true,
            },
            documentFormattingProvider: true,
            signatureHelpProvider: {
                triggerCharacters: ["(", ",", "<"],
                retriggerCharacters: [")"],
            },
        };
        if ((_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) {
            for (const w of (_b = params.workspaceFolders) !== null && _b !== void 0 ? _b : []) {
                workspaceFolders.push({
                    ...w,
                    path: ensureTrailingDirectorySeparator(await fileService.fileURLToRealPath(w.uri)),
                });
            }
            capabilities.workspace = {
                workspaceFolders: {
                    supported: true,
                    changeNotifications: true,
                },
            };
            // eslint-disable-next-line deprecation/deprecation
        }
        else if (params.rootUri) {
            workspaceFolders = [
                {
                    name: "<root>",
                    // eslint-disable-next-line deprecation/deprecation
                    uri: params.rootUri,
                    path: ensureTrailingDirectorySeparator(
                    // eslint-disable-next-line deprecation/deprecation
                    await fileService.fileURLToRealPath(params.rootUri)),
                },
            ];
            // eslint-disable-next-line deprecation/deprecation
        }
        else if (params.rootPath) {
            workspaceFolders = [
                {
                    name: "<root>",
                    // eslint-disable-next-line deprecation/deprecation
                    uri: compilerHost.pathToFileURL(params.rootPath),
                    path: ensureTrailingDirectorySeparator(
                    // eslint-disable-next-line deprecation/deprecation
                    await getNormalizedRealPath(compilerHost, params.rootPath)),
                },
            ];
        }
        log("Workspace Folders", workspaceFolders);
        return { capabilities };
    }
    function initialized(params) {
        isInitialized = true;
        log("Initialization complete.");
    }
    async function workspaceFoldersChanged(e) {
        log("Workspace Folders Changed", e);
        const map = new Map(workspaceFolders.map((f) => [f.uri, f]));
        for (const folder of e.removed) {
            map.delete(folder.uri);
        }
        for (const folder of e.added) {
            map.set(folder.uri, {
                ...folder,
                path: ensureTrailingDirectorySeparator(await fileService.fileURLToRealPath(folder.uri)),
            });
        }
        workspaceFolders = Array.from(map.values());
        log("Workspace Folders", workspaceFolders);
    }
    function watchedFilesChanged(params) {
        fileSystemCache.notify(params.changes);
    }
    async function getFoldingRanges(params) {
        const ast = await compileService.getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        const file = ast.file;
        const ranges = [];
        let rangeStartSingleLines = -1;
        for (let i = 0; i < ast.comments.length; i++) {
            const comment = ast.comments[i];
            if (comment.kind === SyntaxKind.LineComment &&
                i + 1 < ast.comments.length &&
                ast.comments[i + 1].kind === SyntaxKind.LineComment &&
                ast.comments[i + 1].pos === skipWhiteSpace(file.text, comment.end)) {
                if (rangeStartSingleLines === -1) {
                    rangeStartSingleLines = comment.pos;
                }
            }
            else if (rangeStartSingleLines !== -1) {
                addRange(rangeStartSingleLines, comment.end);
                rangeStartSingleLines = -1;
            }
            else {
                addRange(comment.pos, comment.end);
            }
        }
        visitChildren(ast, addRangesForNode);
        function addRangesForNode(node) {
            if (node.kind === SyntaxKind.Doc) {
                return; // fold doc comments as regular comments
            }
            let nodeStart = node.pos;
            if ("decorators" in node && node.decorators.length > 0) {
                const decoratorEnd = node.decorators[node.decorators.length - 1].end;
                addRange(nodeStart, decoratorEnd);
                nodeStart = skipTrivia(file.text, decoratorEnd);
            }
            addRange(nodeStart, node.end);
            visitChildren(node, addRangesForNode);
        }
        return ranges;
        function addRange(startPos, endPos) {
            const start = file.getLineAndCharacterOfPosition(startPos);
            const end = file.getLineAndCharacterOfPosition(endPos);
            if (start.line !== end.line) {
                ranges.push({
                    startLine: start.line,
                    startCharacter: start.character,
                    endLine: end.line,
                    endCharacter: end.character,
                });
            }
        }
    }
    async function getDocumentSymbols(params) {
        const ast = await compileService.getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        return getSymbolStructure(ast);
    }
    async function findDocumentHighlight(params) {
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return [];
        }
        const { program, document, script } = result;
        const identifiers = findReferenceIdentifiers(program, script, document.offsetAt(params.position), [script]);
        return identifiers.map((identifier) => ({
            range: getRange(identifier, script.file),
            kind: DocumentHighlightKind.Read,
        }));
    }
    async function checkChange(change) {
        compileService.notifyChange(change.document);
    }
    async function reportDiagnostics({ program, document }) {
        var _a, _b, _c;
        // Group diagnostics by file.
        //
        // Initialize diagnostics for all source files in program to empty array
        // as we must send an empty array when a file has no diagnostics or else
        // stale diagnostics from a previous run will stick around in the IDE.
        //
        const diagnosticMap = new Map();
        diagnosticMap.set(document, []);
        for (const each of program.sourceFiles.values()) {
            const document = (_a = each.file) === null || _a === void 0 ? void 0 : _a.document;
            if (document) {
                diagnosticMap.set(document, []);
            }
        }
        for (const each of program.diagnostics) {
            let diagDocument;
            const location = getSourceLocation(each.target, { locateId: true });
            if (location === null || location === void 0 ? void 0 : location.file) {
                diagDocument = location.file.document;
            }
            else {
                // https://github.com/microsoft/language-server-protocol/issues/256
                //
                // LSP does not currently allow sending a diagnostic with no location so
                // we report diagnostics with no location on the document that changed to
                // trigger.
                diagDocument = document;
            }
            if (!diagDocument || !fileService.upToDate(diagDocument)) {
                continue;
            }
            const start = diagDocument.positionAt((_b = location === null || location === void 0 ? void 0 : location.pos) !== null && _b !== void 0 ? _b : 0);
            const end = diagDocument.positionAt((_c = location === null || location === void 0 ? void 0 : location.end) !== null && _c !== void 0 ? _c : 0);
            const range = Range.create(start, end);
            const severity = convertSeverity(each.severity);
            const diagnostic = VSDiagnostic.create(range, each.message, severity, each.code, "TypeSpec");
            if (each.code === "deprecated") {
                diagnostic.tags = [DiagnosticTag.Deprecated];
            }
            const diagnostics = diagnosticMap.get(diagDocument);
            compilerAssert(diagnostics, "Diagnostic reported against a source file that was not added to the program.");
            diagnostics.push(diagnostic);
        }
        for (const [document, diagnostics] of diagnosticMap) {
            sendDiagnostics(document, diagnostics);
        }
    }
    async function getHover(params) {
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return { contents: [] };
        }
        const { program, document, script } = result;
        const id = getNodeAtPosition(script, document.offsetAt(params.position));
        const sym = (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? program.checker.resolveIdentifier(id) : undefined;
        const markdown = {
            kind: MarkupKind.Markdown,
            value: sym ? getSymbolDetails(program, sym) : "",
        };
        return {
            contents: markdown,
        };
    }
    async function getSignatureHelp(params) {
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return undefined;
        }
        const { script, document, program } = result;
        const data = getSignatureHelpNodeAtPosition(script, document.offsetAt(params.position));
        if (data === undefined) {
            return undefined;
        }
        const { node, argumentIndex } = data;
        switch (node.kind) {
            case SyntaxKind.TypeReference:
                return getSignatureHelpForTemplate(program, node, argumentIndex);
            case SyntaxKind.DecoratorExpression:
            case SyntaxKind.AugmentDecoratorStatement:
                return getSignatureHelpForDecorator(program, node, argumentIndex);
            default:
                const _assertNever = node;
                compilerAssert(false, "Unreachable");
        }
    }
    function getSignatureHelpForTemplate(program, node, argumentIndex) {
        const sym = program.checker.resolveIdentifier(node.target.kind === SyntaxKind.MemberExpression ? node.target.id : node.target);
        const templateDeclNode = sym === null || sym === void 0 ? void 0 : sym.declarations[0];
        if (!templateDeclNode ||
            !("templateParameters" in templateDeclNode) ||
            templateDeclNode.templateParameters.length === 0) {
            return undefined;
        }
        const parameterDocs = getTemplateParameterDocumentation(templateDeclNode);
        const parameters = templateDeclNode.templateParameters.map((x) => {
            const info = { label: x.id.sv };
            const doc = parameterDocs.get(x.id.sv);
            if (doc) {
                info.documentation = { kind: MarkupKind.Markdown, value: doc };
            }
            return info;
        });
        const help = {
            signatures: [
                {
                    label: `${sym.name}<${parameters.map((x) => x.label).join(", ")}>`,
                    parameters,
                    activeParameter: Math.min(parameters.length - 1, argumentIndex),
                },
            ],
            activeSignature: 0,
            activeParameter: 0,
        };
        const doc = getSymbolDetails(program, sym, {
            includeSignature: false,
            includeParameterTags: false,
        });
        if (doc) {
            help.signatures[0].documentation = { kind: MarkupKind.Markdown, value: doc };
        }
        return help;
    }
    function getSignatureHelpForDecorator(program, node, argumentIndex) {
        const sym = program.checker.resolveIdentifier(node.target.kind === SyntaxKind.MemberExpression ? node.target.id : node.target);
        if (!sym) {
            return undefined;
        }
        const decoratorDeclNode = sym.declarations.find((x) => x.kind === SyntaxKind.DecoratorDeclarationStatement);
        if (decoratorDeclNode === undefined) {
            return undefined;
        }
        const type = program.checker.getTypeForNode(decoratorDeclNode);
        compilerAssert(type.kind === "Decorator", "Expected type to be a decorator.");
        const parameterDocs = getParameterDocumentation(program, type);
        let labelPrefix = "";
        const parameters = [];
        if (node.kind === SyntaxKind.AugmentDecoratorStatement) {
            const targetType = decoratorDeclNode.target.type
                ? program.checker.getTypeForNode(decoratorDeclNode.target.type)
                : undefined;
            parameters.push({
                label: `${decoratorDeclNode.target.id.sv}: ${targetType ? getTypeName(targetType) : "unknown"}`,
            });
            labelPrefix = "@";
        }
        parameters.push(...type.parameters.map((x) => {
            const info = {
                // prettier-ignore
                label: `${x.rest ? "..." : ""}${x.name}${x.optional ? "?" : ""}: ${getTypeName(x.type)}`,
            };
            const doc = parameterDocs.get(x.name);
            if (doc) {
                info.documentation = { kind: MarkupKind.Markdown, value: doc };
            }
            return info;
        }));
        const help = {
            signatures: [
                {
                    label: `${labelPrefix}${type.name}(${parameters.map((x) => x.label).join(", ")})`,
                    parameters,
                    activeParameter: Math.min(parameters.length - 1, argumentIndex),
                },
            ],
            activeSignature: 0,
            activeParameter: 0,
        };
        const doc = getSymbolDetails(program, sym, {
            includeSignature: false,
            includeParameterTags: false,
        });
        if (doc) {
            help.signatures[0].documentation = { kind: MarkupKind.Markdown, value: doc };
        }
        return help;
    }
    async function formatDocument(params) {
        const document = host.getOpenDocumentByURL(params.textDocument.uri);
        if (document === undefined) {
            return [];
        }
        const formattedText = await formatTypeSpec(document.getText(), {
            tabWidth: params.options.tabSize,
            useTabs: !params.options.insertSpaces,
        });
        return [minimalEdit(document, formattedText)];
    }
    function minimalEdit(document, string1) {
        const string0 = document.getText();
        // length of common prefix
        let i = 0;
        while (i < string0.length && i < string1.length && string0[i] === string1[i]) {
            ++i;
        }
        // length of common suffix
        let j = 0;
        while (i + j < string0.length &&
            i + j < string1.length &&
            string0[string0.length - j - 1] === string1[string1.length - j - 1]) {
            ++j;
        }
        const newText = string1.substring(i, string1.length - j);
        const pos0 = document.positionAt(i);
        const pos1 = document.positionAt(string0.length - j);
        return TextEdit.replace(Range.create(pos0, pos1), newText);
    }
    async function gotoDefinition(params) {
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return [];
        }
        const id = getNodeAtPosition(result.script, result.document.offsetAt(params.position));
        const sym = (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? result.program.checker.resolveIdentifier(id) : undefined;
        return getLocations(sym === null || sym === void 0 ? void 0 : sym.declarations);
    }
    async function complete(params) {
        const completions = {
            isIncomplete: false,
            items: [],
        };
        const result = await compileService.compile(params.textDocument);
        if (result) {
            const { script, document, program } = result;
            const node = getCompletionNodeAtPosition(script, document.offsetAt(params.position));
            await resolveCompletion({
                program,
                file: script,
                completions,
                params,
            }, node);
        }
        return completions;
    }
    async function findReferences(params) {
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return [];
        }
        const identifiers = findReferenceIdentifiers(result.program, result.script, result.document.offsetAt(params.position));
        return getLocations(identifiers);
    }
    async function prepareRename(params) {
        var _a;
        const result = await compileService.compile(params.textDocument);
        if (result === undefined) {
            return undefined;
        }
        const id = getNodeAtPosition(result.script, result.document.offsetAt(params.position));
        return (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? (_a = getLocation(id)) === null || _a === void 0 ? void 0 : _a.range : undefined;
    }
    async function rename(params) {
        const changes = {};
        const result = await compileService.compile(params.textDocument);
        if (result) {
            const identifiers = findReferenceIdentifiers(result.program, result.script, result.document.offsetAt(params.position));
            for (const id of identifiers) {
                const location = getLocation(id);
                if (!location) {
                    continue;
                }
                const change = TextEdit.replace(location.range, params.newName);
                if (location.uri in changes) {
                    changes[location.uri].push(change);
                }
                else {
                    changes[location.uri] = [change];
                }
            }
        }
        return { changes };
    }
    function findReferenceIdentifiers(program, file, pos, searchFiles = program.sourceFiles.values()) {
        const id = getNodeAtPosition(file, pos);
        if ((id === null || id === void 0 ? void 0 : id.kind) !== SyntaxKind.Identifier) {
            return [];
        }
        const sym = program.checker.resolveIdentifier(id);
        if (!sym) {
            return [id];
        }
        const references = [];
        for (const searchFile of searchFiles) {
            visitChildren(searchFile, function visit(node) {
                if (node.kind === SyntaxKind.Identifier) {
                    const s = program.checker.resolveIdentifier(node);
                    if (s === sym || (sym.type && (s === null || s === void 0 ? void 0 : s.type) === sym.type)) {
                        references.push(node);
                    }
                }
                visitChildren(node, visit);
            });
        }
        return references;
    }
    async function getSemanticTokensForDocument(params) {
        const ast = await compileService.getScript(params.textDocument);
        if (!ast) {
            return [];
        }
        return getSemanticTokens(ast);
    }
    async function buildSemanticTokens(params) {
        const builder = new SemanticTokensBuilder();
        const tokens = await getSemanticTokensForDocument(params);
        const file = await compilerHost.readFile(await fileService.getPath(params.textDocument));
        const starts = file.getLineStarts();
        for (const token of tokens) {
            const start = file.getLineAndCharacterOfPosition(token.pos);
            const end = file.getLineAndCharacterOfPosition(token.end);
            for (let pos = token.pos, line = start.line; line <= end.line; line++) {
                const endPos = line === end.line ? token.end : starts[line + 1];
                const character = line === start.line ? start.character : 0;
                builder.push(line, character, endPos - pos, token.kind, 0);
                pos = endPos;
            }
        }
        return builder.build();
    }
    function documentClosed(change) {
        // clear diagnostics on file close
        sendDiagnostics(change.document, []);
    }
    function getLocations(targets) {
        var _a;
        return (_a = targets === null || targets === void 0 ? void 0 : targets.map(getLocation).filter((x) => !!x)) !== null && _a !== void 0 ? _a : [];
    }
    function getLocation(target) {
        const location = getSourceLocation(target);
        if (location.isSynthetic) {
            return undefined;
        }
        return {
            uri: fileService.getURL(location.file.path),
            range: getRange(location, location.file),
        };
    }
    function getRange(location, file) {
        const start = file.getLineAndCharacterOfPosition(location.pos);
        const end = file.getLineAndCharacterOfPosition(location.end);
        return Range.create(start, end);
    }
    function convertSeverity(severity) {
        switch (severity) {
            case "warning":
                return DiagnosticSeverity.Warning;
            case "error":
                return DiagnosticSeverity.Error;
        }
    }
    function log(message, details = undefined) {
        message = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (details) {
            message += ": " + JSON.stringify(details, undefined, 2);
        }
        if (!isInitialized) {
            pendingMessages.push(message);
            return;
        }
        for (const pending of pendingMessages) {
            host.log(pending);
        }
        pendingMessages = [];
        host.log(message);
    }
    function sendDiagnostics(document, diagnostics) {
        host.sendDiagnostics({
            uri: document.uri,
            version: document.version,
            diagnostics,
        });
    }
    function createCompilerHost() {
        const base = host.compilerHost;
        return {
            ...base,
            parseCache: new WeakMap(),
            readFile,
            stat,
            getSourceFileKind,
        };
        async function readFile(path) {
            const document = fileService.getOpenDocument(path);
            const cached = await fileSystemCache.get(path);
            // Try cache
            if (cached && (!document || document.version === cached.version)) {
                if (cached.type === "error") {
                    throw cached.error;
                }
                return cached.file;
            }
            // Try open document, although this is cheap, the instance still needs
            // to be cached so that the compiler can reuse parse and bind results.
            if (document) {
                const file = {
                    document,
                    ...createSourceFile(document.getText(), path),
                };
                fileSystemCache.set(path, { type: "file", file, version: document.version });
                return file;
            }
            // Hit the disk and cache
            try {
                const file = await base.readFile(path);
                fileSystemCache.set(path, { type: "file", file });
                return file;
            }
            catch (error) {
                fileSystemCache.set(path, { type: "error", error });
                throw error;
            }
        }
        async function stat(path) {
            var _a;
            // if we have an open document for the path or a cache entry, then we know
            // it's a file and not a directory and needn't hit the disk.
            if (fileService.getOpenDocument(path) || ((_a = (await fileSystemCache.get(path))) === null || _a === void 0 ? void 0 : _a.type) === "file") {
                return {
                    isFile() {
                        return true;
                    },
                    isDirectory() {
                        return false;
                    },
                };
            }
            return await base.stat(path);
        }
        function getSourceFileKind(path) {
            const document = fileService.getOpenDocument(path);
            if ((document === null || document === void 0 ? void 0 : document.languageId) === "typespec") {
                return "typespec";
            }
            return getSourceFileKindFromExt(path);
        }
    }
}
function getSignatureHelpNodeAtPosition(script, position) {
    // Move back over any trailing trivia. Otherwise, if there is no
    // closing paren/angle bracket, we can find ourselves outside the desired
    // node altogether in cases like `@dec(test, |`.
    position = getPositionBeforeTrivia(script, position);
    const node = getNodeAtPosition(script, position, (n) => {
        switch (n.kind) {
            case SyntaxKind.DecoratorExpression:
            case SyntaxKind.AugmentDecoratorStatement:
            case SyntaxKind.TypeReference:
                // Do not consider node if positioned before the argument list.
                // This is the standard behavior for signature help and further
                // deals with nesting such as `Outer<Inner|> where we do not want
                // we want help with the `Outer` arguments, not the `Inner` ones.
                if (position <= n.target.end) {
                    return false;
                }
                // Likewise, no signature help at the end of argument list unless the
                // it has no closing paren/angle bracket.
                if (position === n.end) {
                    const endChar = script.file.text.charCodeAt(position - 1);
                    const closeChar = n.kind === SyntaxKind.TypeReference ? 62 /* CharCode.GreaterThan */ : 41 /* CharCode.CloseParen */;
                    if (endChar === closeChar) {
                        return false;
                    }
                }
                return true;
            default:
                return false;
        }
    });
    if (!node) {
        return undefined;
    }
    const argumentIndex = getSignatureHelpArgumentIndex(script, node, position);
    if (argumentIndex < 0) {
        return undefined;
    }
    return { node, argumentIndex };
}
function getSignatureHelpArgumentIndex(script, node, position) {
    // Normalize arguments into a single list to avoid special case for
    // augment decorators.
    const args = node.kind === SyntaxKind.AugmentDecoratorStatement
        ? [node.targetType, ...node.arguments]
        : node.arguments;
    // Find the first argument that ends after the position. We don't look at
    // the argument start position since the cursor might be in leading
    // trivia, and we skip trivia to get the effective argument end position
    // since the cursor might be in trailing trivia.
    for (let i = 0; i < args.length; i++) {
        if (position <= skipTrivia(script.file.text, args[i].end)) {
            return i;
        }
    }
    // If we reach here, we must be at the next argument after any that are in
    // the syntax tree. There won't be a missing identifier for this argument
    // in the tree since the parser error recovery will have assumed a
    // trailing delimiter or empty list.
    return args.length;
}
/**
 * Resolve the node that should be auto completed at the given position.
 * It will try to guess what node it could be as during auto complete the ast might not be complete.
 * @internal
 */
export function getCompletionNodeAtPosition(script, position, filter = (node) => true) {
    const realNode = getNodeAtPosition(script, position, filter);
    if ((realNode === null || realNode === void 0 ? void 0 : realNode.kind) === SyntaxKind.StringLiteral) {
        return realNode;
    }
    // If we're not immediately after an identifier character, then advance
    // the position past any trivia. This is done because a zero-width
    // inserted missing identifier that the user is now trying to complete
    // starts after the trivia following the cursor.
    const cp = codePointBefore(script.file.text, position);
    if (!cp || !isIdentifierContinue(cp)) {
        const newPosition = skipTrivia(script.file.text, position);
        if (newPosition !== position) {
            return getNodeAtPosition(script, newPosition, filter);
        }
    }
    return realNode;
}
//# sourceMappingURL=serverlib.js.map