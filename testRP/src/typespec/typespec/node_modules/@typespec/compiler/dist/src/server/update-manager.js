var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UpdateManger_instances, _UpdateManger_pendingUpdates, _UpdateManger_updateCb, _UpdateManger_scheduleBatchUpdate, _UpdateManger_update;
import { UPDATE_DEBOUNCE_TIME } from "./constants.js";
/**
 * Track file updates and recompile the affected files after some debounce time.
 */
export class UpdateManger {
    constructor(updateCb) {
        _UpdateManger_instances.add(this);
        _UpdateManger_pendingUpdates.set(this, new Map());
        _UpdateManger_updateCb.set(this, void 0);
        _UpdateManger_scheduleBatchUpdate.set(this, debounceThrottle(() => {
            __classPrivateFieldGet(this, _UpdateManger_pendingUpdates, "f").forEach((update) => {
                void __classPrivateFieldGet(this, _UpdateManger_instances, "m", _UpdateManger_update).call(this, update);
            });
            __classPrivateFieldGet(this, _UpdateManger_pendingUpdates, "f").clear();
        }, UPDATE_DEBOUNCE_TIME));
        __classPrivateFieldSet(this, _UpdateManger_updateCb, updateCb, "f");
    }
    scheduleUpdate(document) {
        const existing = __classPrivateFieldGet(this, _UpdateManger_pendingUpdates, "f").get(document.uri);
        if (existing === undefined) {
            __classPrivateFieldGet(this, _UpdateManger_pendingUpdates, "f").set(document.uri, {
                latest: document,
            });
        }
        else {
            existing.latest = document;
        }
        __classPrivateFieldGet(this, _UpdateManger_scheduleBatchUpdate, "f").call(this);
    }
}
_UpdateManger_pendingUpdates = new WeakMap(), _UpdateManger_updateCb = new WeakMap(), _UpdateManger_scheduleBatchUpdate = new WeakMap(), _UpdateManger_instances = new WeakSet(), _UpdateManger_update = async function _UpdateManger_update(update) {
    await __classPrivateFieldGet(this, _UpdateManger_updateCb, "f").call(this, update.latest);
};
/**
 * Debounces a function but also waits at minimum the specified number of milliseconds until
 * the next invocation. This avoids needless calls when a synchronous call (like diagnostics)
 * took too long and the whole timeout of the next call was eaten up already.
 *
 * @param fn The function
 * @param milliseconds Number of milliseconds to debounce/throttle
 */
export function debounceThrottle(fn, milliseconds) {
    let timeout;
    let lastInvocation = Date.now() - milliseconds;
    function maybeCall() {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            if (Date.now() - lastInvocation < milliseconds) {
                maybeCall();
                return;
            }
            fn();
            lastInvocation = Date.now();
        }, milliseconds);
    }
    return maybeCall;
}
//# sourceMappingURL=update-manager.js.map